<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[关于深度学习的一些基础知识]]></title>
      <url>%2F2017%2F09%2F14%2F%E5%85%B3%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[Supervised Learning 监督学习 Structured Data 结构化数据 是指像数据库里的数据,有数据特征和属性.机器更易解读. Unstructured Data 非结构化数据 指类似音频Audio,图片Image,文本Text.人们更易解读. Standard NN 标准神经网络 Convolutional NN 卷积神经网络 Recurrent NN 循环神经网络(暂译) 传统模式识别方法 ①传感器获取数据 ②预处理 ③特征提取 ——-&gt;主要靠人工提取,深入学习的出现为机器能不能自动学习特征,提供了一种解决方案 ④特征选择就 ⑤推理 ⑥预测或识别 机器学习的三大阶段 一,1956年–&gt;出现神经网络模型,由于当时的计算能力和数据量较少,进入寒冬期 二,1980年–&gt;专家系统,人工智能项目,政府投入缩减,再次搁置.1997年–&gt;IBM研发的深蓝战胜国际围棋冠军. 三,2006年–&gt;提出深度学习网络.2011年,苹果 Siri.2012年,Google的无人车.2016年,阿尔法战胜围棋冠军. 待续…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记-虚拟机装Mac系统]]></title>
      <url>%2F2017%2F08%2F12%2F%E8%AE%B0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A3%85Mac%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[记,虚拟机装Mac系统前两天在B站关注了一个叫啃芝士的账号,经常分享一些科普的视频.推荐关注. 有个视频讲到了用VirtualBox装Mac系统的操作,感觉很神奇,就Google了一下,按照教程,装了一下,参考的是一个论坛的方案,安装方法 具体步骤: 首先安装Oracle VM VirtualBox到本机电脑 下载系统镜像,网盘镜像文件 解压镜像文件,会有一个.vmdk的文件,备用. 按照安装方法,新建虚拟系统,设置内存大小 按照安装方法,新建虚拟电脑 设置内存大小,以自己电脑情况来定. 找到解压文件的位置,添加解压好的.vmdk文件 设置系统属性 然后关闭虚拟机,在VirtualBox的安装位置打开命令行,输入下面命令: 1VBoxManage.exe modifyvm 电脑名称 ----cpuidset 00000001 000106e5 00100800 0098e3fd bfebfbff 1VBoxManage setextradata 电脑名称 &quot;VBoxInternal/Devices/efi/0/Config/DmiSystemProduct&quot; &quot;iMac11,3&quot; 1VBoxManage setextradata 电脑名称 &quot;VBoxInternal/Devices/efi/0/Config/DmiSystemVersion&quot; &quot;1.0&quot; 1VBoxManage setextradata 电脑名称 &quot;VBoxInternal/Devices/efi/0/Config/DmiBoardProduct&quot; &quot;Iloveapple&quot; 1VBoxManage setextradata电脑名称 &quot;VBoxInternal/Devices/smc/0/Config/DeviceKey&quot;&quot;ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc&quot; 1VBoxManage setextradata 电脑名称 &quot;VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC&quot; 1 注意以上命令行的文字,尽量复制粘贴. 然后,打开虚拟机,启动新的虚拟电脑 电脑会进行初始化,等1分钟,就会出现 后面的就可以自己慢慢折腾了…. 再次感谢原博主的教程.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[无题]]></title>
      <url>%2F2017%2F07%2F24%2F%E6%97%A0%E9%A2%98%2F</url>
      <content type="text"><![CDATA[无题闲下来的时候,想了想,还是应该写点文字来记录一下失落时候的想法. 距离上次更新,已经有近55天的时间.上次写的是一些技术类的文章,然而,我并不全会写些技术类的文章.我也想写一写类似记事类的文章,来锻炼下自己的语言组织能力. 回想一下,这么多天,你都做了些什么呢? 首先,我加入了一家带有亲属关系的物流公司,学习如何做业务销售.从一开始,就有一位曾经做过业务经理的销售精英来教我一些基本知识,基本流程,基本概念.从点到线在到面,可以说是很详细了.师傅教的很好,我学的还可以,基本能听懂.后面大部分的时间就是,客人向我咨询的,不明白的,在来问她.所以,记忆上也没太下功夫,直到自己意识到了,才直到用笔记录到笔记本上面,方便以后的复习,加深记忆. 第一次业务开会,老板有问我下个月有什么计划?我的回答很笼统,没有具体的目标.就是在语言表达能力上能有所提升.可能是之前几个月都没有给自己定过什么目标,哪怕是小的,导致自己的思想很懒散.也可能是定了一些小目标,放在心里,吃过饭,或者上个厕所就忘了.现在才意识到为自己定下目标的的重要性,哪怕是小的.老板给的目标是,一个月,四个周,一周2个客户,总共8个客户,1吨货量的要求.今天是24号,我完成的情况目前是,3个客户,还不到100kg的货量.老板当时说要对自己有信心.而现在,我的信心所剩无几.虽然我不服输… 第二次开会是上周六,是老板大病初愈的第一次会议,问了问我们业务最近的情况,对产品特性是否够了解以及工作中出现的疑难问题,有哪些是老板可以提供帮助的.大概也就1个小时的时间. 其实我一直对自己将来的打算很迷茫,直到有次我跟着一位同事出去送货,他问了问我最近的情况,工资怎么样?业务怎么样?我不用回答,他也直到,因为所有的货,都是经过他们的手来收货,验货,再出货的.他说了一句,那你现在的情况很危险哦.当时我也就笑笑的迎合了一下,就转开了话题.那句话对我的内心波动挺大的.我是93年的人,到现在毕业也快两年了,还没有一些小小的成就,哪怕是小小的.心里也挺尴尬的. 偶尔和同学聊天发现,这样的情况不单单只是我一个人. 我有个叫文武的同学,他常跟我说,我是个无业游民(因为我有一段时间没有工作),我也常笑着回答他,嗯,是的.你是不是羡慕我之类的话.虽然在开玩笑,但还是有挺大感触的,在这个社会上,没有点技能,以后就会被淘汰了.虽然有点技能,还是可能会被淘汰… 他也跟我说,谁还没有点梦想,我也想做健身教练(他之前做过一段时间的健身教练,但是因为工资低,家里不同意,辞掉了),现在在做的工作(养猪厂,不要笑,我们都是是学兽医的,对,是兽医),就是在为你将来的梦想铺路.当你有点资本了,你就会慢慢实现一个个当时吹过的牛逼… 我还有个叫智斌的同学,在大学就住一起,感情颇深,他说他很迷茫,我说你不是都有了工作了吗?迷茫什么?他说总感觉不踏实,我说为什么?他说不知道,总想自己找点事做.不想做这个了(他是在做饲料销售工作),我说你想做什么?他说不知道,想几个人一起搞点事情. 后来,他谈了恋爱,再次聊天,就是帮他参考一些送女友的礼物(对我这个单身汪星人造成无穷大的伤害),他还是说现在很迷茫,现在的收入,只够自己基本的衣食住行,还是想换个工作试下.我也没有发表什么意见,因为我现在提不出更有价值的建议,怕会因为一句话而改变了一个人的决定(可能是我想多了).我只能希望他能和他的女友早日步入婚姻的殿堂,恩爱到老. 当然,现在的我,扪心自问,都不知道自己将来怎么办.你知道吗?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Django基础知识]]></title>
      <url>%2F2017%2F06%2F06%2FDjango%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[DjangoDjango官网 安装方式: pip install django 目录文件 manage.py 该文件时django项目的项目管理器,用于管理项目,启动服务等 urls.py 用于配置项目的url settings.py 项目总的配置文件,管理数据库,App,url连接和模板 wsgi.py python 服务网管接口,应用与web服务器之间的接口 创建项目在合适的文件目录下,打开命令行,建立django项目: python manage.py startproject 项目名称 在manage.py的统计目录下打开命令行,创建新的APP: python manage.py startapp App名称 启动服务,在manage.py的同级目录下,打开命令行输入: python manage.py runserver 如果想指定端口或网址: python manage.py runserver 指定网址 : 端口号 python manage.py runserver 端口号 App项目文件 admin.py 是应用后台的管理文件 apps.py 是App配置的文件,可管理项目名称,不建议修改 models.py 是数据库模块,django使用ORM框架,对象关系映射 tests.py 是自动化测试模块,用于测试项目 views.py 是执行响应代码的模块,处理逻辑的模块,代码编辑大部分都在这里 新建模板: 在App项目下新建Templates文件夹,文件夹下新建.html文件. 创建数据库: python manage.py makemigrations 迁移数据库: python manage.py migrate 查看sql语句: python manage.py sqlmigrate 创建管理员: python manage.py createsuperuser localhost:8000/admin 管理页面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(十)]]></title>
      <url>%2F2017%2F05%2F16%2FPython%E5%AD%A6%E4%B9%A0%E5%8D%81%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 网络编程网络编程就是如何实现两台计算机的通信,互联网时代的到来,现在程序基本都是联网的了,很少有单机类的了,计算机网络就是把各个计算机连接起来,让其在网络中可以通信. TCP/IP计算机要想联网,就必须规定通信协议,早起的计算机网络都是些私人的网络协议,互不兼容.为了把全世界的不通类型的计算机连接起来,就要规定一套全球通用的网络通信协议.最重要的两个协议就是TCP和IP协议. IP协议负责把数据从一台计算机通过网络发送到另一台计算机上.特点是:按块发送,途径多个路由,不能保证到达,不能保证顺序到达. 每台计算机的唯一标示就是IP地址. TCP协议是建立在IP协议之上的,它负责两台计算机之间建立可靠连接,保证数据包的安全到达,通过三次握手建立连接,对IP包编号,确保对方按顺序收到,如丢包,则自动重发. IP包除了包含要传输的数据外,还包含源IP地址和目标IP地址,源端口和目标端口 TCP编程Socket一个Socket表示’打开了一个网络连接,使用Socket需要知道目标计算机的IP地址和端口,指定协议类型就可以了. 客户端创建TCP连接时,主动发起连接的叫客户端,被动响应连接的叫服务器. socket文档 创建一个基于TCP的Socket: 123456789# Echo client programimport socketHOST = &apos;daring.cwi.nl&apos; # The remote hostPORT = 50007 # The same port as used by the serverwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b&apos;Hello, world&apos;) data = s.recv(1024)print(&apos;Received&apos;, repr(data)) 先导入socket包,指定Host,端口号PORT,协议类型:AF_INET代表IPv4协议,AF_INET6表示IPv6协议.SOCK_STREAM指定使用面向流的TCP协议. sendall()发送数据,recv()接收数据,可以指定接收容量(字节数).close()方法关闭连接. 建立的Socket连接是双向的,双方都可以给对方发送数据.先后顺序由协议来决定. 服务器服务器进程需要绑定一个端口监听来自其他客户端的连接,如果连接了,就和该客户端建立Socket连接和通信. 一个Socket由服务器地址,服务器端口,客户端地址,客户端端口来确定.服务器需要同时响应多个客户端请求,因此,需要新的进程或线程来处理,否则,服务器一次就只能服务一个客户端. 创建服务器端: 1234567891011121314# Echo server programimport socketHOST = &apos;&apos; # Symbolic name meaning all available interfacesPORT = 50007 # Arbitrary non-privileged portwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen(1) conn, addr = s.accept() with conn: print(&apos;Connected by&apos;, addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) bind()方法绑定地址和端口.listen()方法用来监听端口,参数代表等待连接的数量. 例图: 客户端要主动连接服务器,服务器监听指定端口,对每个新来的连接,创建一个线程或进程来处理.同一个端口,被一个Socket绑定后,就不能被别的Socket绑定了. UDP编程UDP与TCP相比,UDP是无连接的协议,不需要建立连接,确定IP地址和端口号就可以发送数据包了,速度快.但不保证是否到达.传输数据不可靠. 创建UDP服务端:1234567891011import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口:s.bind((&apos;127.0.0.1&apos;, 8973)print(&apos;Bind UDP on 8973...&apos;)while True: # 接收数据: data, addr = s.recvfrom(1024) print(&apos;Received from %s:%s.&apos; % addr) reply = &apos;Hi, %s!&apos; % data.decode(&apos;utf-8&apos;) s.sendto(reply.encode(&apos;utf-8&apos;), addr) SOCK_DGRAM代表Socket是UDP类型,不需要监听端口,recvfrom()返回数据和客户端的地址和端口. 创建UDP客户端:12345678import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b&apos;Stark&apos;, b&apos;Captain&apos;, b&apos;Thor&apos;]: # 发送数据: s.sendto(data, (&apos;127.0.0.1&apos;, 8973)) # 接收数据: print(s.recv(1024).decode(&apos;utf-8&apos;))s.close() 不需要连接时才发送,直接发送数据过,recv()方法从服务器接收数据. 例图:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(九)]]></title>
      <url>%2F2017%2F05%2F11%2FPython%E5%AD%A6%E4%B9%A0%E4%B9%9D%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 常用的第三方模块Python既有内建模块,还有大量的第三方模块,模块网址按需安装 PIL全称是: Python Imaging Library 是Python的图像处理标准库,功能强大且易用,仅支持到Python 2.7 Pillow支持最新Python3.X 安装方式: pip install pillow 操作缩放图像: 123456789&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; i = Image.open(&apos;C:/Users/snow/Desktop/img/boy.jpg&apos;)&gt;&gt;&gt; w,h = i.size&gt;&gt;&gt; print(&apos;Image size: %s*%s&apos; % (w,h))Image size: 1080*1002&gt;&gt;&gt; i.thumbnail((w//2,h//2))&gt;&gt;&gt; print(&apos;Image size: %s*%s&apos; % (w//2,h//2))Image size: 540*501&gt;&gt;&gt; i.save(&apos;thumboy.jpg&apos;,&apos;jpeg&apos;) 图片模糊: 1234&gt;&gt;&gt; from PIL import Image,ImageFilter&gt;&gt;&gt; ii = Image.open(&apos;C:/Users/snow/Desktop/img/iii.png&apos;)&gt;&gt;&gt; iii = ii.filter(ImageFilter.BLUR)&gt;&gt;&gt; iii.save(&apos;ib.png&apos;,&apos;png&apos;) virtualenv为Python应用提供不同的独立的Python运行环境,以适应不同版本 安装方法: pip install virtualenv windows环境下的使用: 打开命令提示符,可以指定位置,使用 python -m venv 文件名 就可以创建一个独立的干净的没有第三方库的Python运行环境. 在此环境下使用pip安装其他库,就会安装在新创建的环境中, 图像界面Tkinter文档地址 官方解释: The tkinter package (“Tk interface”) is the standard Python interface to the Tk GUI toolkit. Both Tk and tkinter are available on most Unix platforms, as well as on Windows systems. (Tk itself is not part of Python; it is maintained at ActiveState.) You can check that tkinter is properly installed on your system by running python -m tkinter from the command line; this should open a window demonstrating a simple Tk interface. 可以看出,tkinter是Tk 图形库的一个标准Python接口,既可以在Unix平台上,也可以在Windows平台上运行,Tk它本身并不是Python的一部分,还在维护.可以在命令行窗口直接输入 python -m tkinter 就会弹出一个窗口. Hello World窗口示例: 1234567891011121314151617181920212223import tkinter as tkclass Application(tk.Frame): def init(self, master=None): super().init(master) self.pack() self.create_widgets() def create_widgets(self): self.hi_there = tk.Button(self) self.hi_there[&quot;text&quot;] = &quot;Hello World\n(click me)&quot; self.hi_there[&quot;command&quot;] = self.say_hi self.hi_there.pack(side=&quot;top&quot;) self.quit = tk.Button(self, text=&quot;QUIT&quot;,fg=&quot;red&quot;, command=root.destroy) self.quit.pack(side=&quot;bottom&quot;) def say_hi(self): print(&quot;hi there, everyone!&quot;)root = tk.Tk()app = Application(master=root)app.mainloop() 点击一下,可以在命令行里输出”hi there,everyone!”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(八)]]></title>
      <url>%2F2017%2F04%2F18%2FPython%E5%AD%A6%E4%B9%A0%E5%85%AB%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 struct模块struct模块是Python来解决bytes和其他二进制数据类型的转换. pack函数struct的pack函数把任意数据类型变成bytes: 12&gt;&gt;&gt; import struct&gt;&gt;&gt; struct.pack(&apos;&gt;I&apos;, 10240099)b&apos;\x00\x9c@c&apos; pack的第一个参数是处理指令,”&gt;I“的意思是: >表示字节顺序是big-endian,就是网络序, I 表示4字节无符号整数. 后面的参数个数要和处理指令一致. unpack函数unpack函数可以把bytes变成相应的数据类型: 12&gt;&gt;&gt; struct.unpack(&apos;&gt;IH&apos;, b&apos;\xf0\xf0\xf0\xf0\x80\x80&apos;)(4042322160, 32896) “&gt;IH”表示,后面bytes依次变为I: 4字节无符号整数和H: 2字节无符号整数. struct参考文档 使用struct分析windows位图文件(bmp),bmp是一种简单的文件格式. 首先,找到一个bmp文件,读入前30个字节来分析: 1&gt;&gt;&gt; s = b&apos;\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00&apos; BMP格式采用小端方式存储数据,文件头的结构顺序: 两个字节：’BM’表示Windows位图，’BA’表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。 组合起来用struct读取: 12&gt;&gt;&gt; struct.unpack(&apos;&lt;ccIIIIIIHH&apos;, s)(b&apos;B&apos;, b&apos;M&apos;, 691256, 0, 54, 40, 640, 360, 1, 24) b’B’,b’M’表示是windows位图,位图大小是:640*360,颜色数是24 练习:检查一个文件是否是位图文件 ,如果是就打印出图片大小和颜色数: 123456789101112131415import structdef isbmp(files): with open(files, &apos;rb&apos;) as fp: bitOfBmp = fp.read(30) if(len(bitOfBmp) &lt; 30): print(&apos;The file is not a bitmap.&apos;) else: fileInfo = struct.unpack(&apos;&lt;ccIIIIIIHH&apos;, bitOfBmp) if(fileInfo[0] == b&apos;B&apos; and fileInfo[1] == b&apos;M&apos;): print(&apos;The size of BitMap is %s * %s, #color is %s&apos; % (fileInfo[6], fileInfo[7], fileInfo[9])) else: print(&apos;The file is not a bitmap for windows.&apos;)if (name == &apos;main&apos;): isbmp(r&apos;C:/Users/snow/Desktop/img/6.bmp&apos;) hashlib摘要算法:hashlib模块为Python提供了常见的摘要算法,如MD5,SHA1. 摘要算法又称哈希算法,散列算法,通过一个函数,把任意长度的数据转换为一个长度固定的数据串,(用16进制的字符串表示). 通过摘要函数f(),对任意长度的数据data计算出固定长度的摘要digest,目的是为了发现原始数据是否被人篡改过. 摘要函数是一个单向函数,计算f(data)简单,但通过digest反过来推算data很困难,原始数据的一个bit的修改,都会导致计算出的结果不同. MD51234&gt;&gt;&gt; import hashlib&gt;&gt;&gt; md5 = hashlib.md5()&gt;&gt;&gt; md5.update(&apos;how to introduce yourself?&apos;.encode(&apos;utf-8&apos;))&gt;&gt;&gt; print(md5.hexdigest()) 结果: 184cbf48524a29ac5ca1eed0b68468a0a MD5是最常见的摘要算法,速度很快,生成结果是固定的128bit字节,通常用一个32位的16进制字符串表示. SHA1使用方法和MD5类似: 1234&gt;&gt;&gt; import hashlib&gt;&gt;&gt; sh = hashlib.sha1()&gt;&gt;&gt; sh.update(&apos;how to introduce yourself?&apos;.encode(&apos;utf-8&apos;))&gt;&gt;&gt; print(sh.hexdigest()) 结果: 168f18af3fab0438265d5d6675bb74e5a41a2e585 SHA1的结果是160bit字节,用40位的16进制字符串表示. 比SHA1更安全的算法是,SHA256和SHA512,但是,越安全的算法会越慢,摘要长度也更长. 摘要算法的应用 在用户登录网站时,首先计算用户输入的明文口令的MD5,然后和数据库存储的MD5进行比较,如果一直,说明口令正确,不一致,口令错误. 123456789101112131415161718192021222324252627282930import hashlibdef login(user,password): db = &#123; &apos;michael&apos;: &apos;e10adc3949ba59abbe56e057f20f883e&apos;, &apos;bob&apos;: &apos;878ef96e86145580c38c87f0410ad153&apos;, &apos;alice&apos;: &apos;99b1c2188db85afee403b1536010c2c9&apos;&#125; md5 = hashlib.md5() md5.update(password.encode(&apos;utf-8&apos;)) if user == &apos;michael&apos;: if md5.hexdigest() == db[&apos;michael&apos;]: print(&apos;michael password is true&apos;) else: print(&apos;michael password is false&apos;) elif user==&apos;bob&apos;: if md5.hexdigest() == db[&apos;bob&apos;]: print(&apos;bob password is true&apos;) else: print(&apos;bob password is false&apos;) elif user == &apos;alice&apos;: if md5.hexdigest() == db[&apos;alice&apos;]: print(&apos;alice password is true&apos;) else: print(&apos;alice password is false&apos;) if __name__ == &apos;__main__&apos;: login(&apos;michael&apos;,&apos;123456&apos;) #login(&apos;bob&apos;,&apos;abc99&apos;) #login(&apos;michael&apos;,&apos;alice2008&apos;) 有了MD5口令也不一定安全,对于常用口令的MD5值很容易算出来,在原始口令基础上加上一个复杂字符串,再进行计算MD5的值,可以提高口令的安全性.这种方法俗称”加盐”. 12def salt_MD5(password): return get_md5(password + &apos;the-Salt&apos;) salt处理后的MD5值,只要salt不被外人知道,很难通过MD5反推明文. 摘要算法不是加密算法,不能用于加密(无法通过摘要反推明文),只能用于防篡改,有单向计算的特性. itertoolsPython内建模块itertools提供了非常有用的用于操作迭代对象的函数. count()count()是itertools中提供的无限迭代器,一直打印自然数列,按 ctrl+c 停止. 12345678&gt;&gt;&gt; import itertools&gt;&gt;&gt; nums = itertools.count()&gt;&gt;&gt; for num in nums:... print(num)123... cycle()cycle()方法是会进行重复循环输出.ctrl + c 停止输出. 123456789101112&gt;&gt;&gt; import itertools&gt;&gt;&gt; cyc = itertools.cycle(&apos;SNOW&apos;)&gt;&gt;&gt; for c in cyc:... print(c)SNOWSNOW repeat()repeat()函数,负责把一个元素无限重复,第二个参数可以规定重复的次数: 123456789&gt;&gt;&gt; import itertools&gt;&gt;&gt; re = itertools.repeat(&apos;s&apos;,4)&gt;&gt;&gt; for r in re:... print(r)...ssss takewhile()截取一个有序的序列: 1234&gt;&gt;&gt; num = itertools.count(3)&gt;&gt;&gt; n = itertools.takewhile(lambda x: x &lt;= 10,num)&gt;&gt;&gt; list(n)[3, 4, 5, 6, 7, 8, 9, 10] count()中的参数,是起始位置,talkwhile()截取了从起始位置开始到小于等于10之间的数字序列. chain()chain()可以把一组迭代对象串联起来, 12345678910&gt;&gt;&gt; import itertools&gt;&gt;&gt; for w in itertools.chain(&apos;ABC&apos;,&apos;XYZ&apos;):... print(w)...ABCXYZ groupby()把迭代器中相邻的重复元素挑出来放在一起. 1234567&gt;&gt;&gt; for w,word in itertools.groupby(&apos;WWWWWOOOOOOOORRRDDDDDD&apos;):... print(w,list(word))...W [&apos;W&apos;, &apos;W&apos;, &apos;W&apos;, &apos;W&apos;, &apos;W&apos;]O [&apos;O&apos;, &apos;O&apos;, &apos;O&apos;, &apos;O&apos;, &apos;O&apos;, &apos;O&apos;, &apos;O&apos;, &apos;O&apos;]R [&apos;R&apos;, &apos;R&apos;, &apos;R&apos;]D [&apos;D&apos;, &apos;D&apos;, &apos;D&apos;, &apos;D&apos;, &apos;D&apos;, &apos;D&apos;] 1234567&gt;&gt;&gt; for k,word in itertools.groupby(&apos;AaaaaBbBbbcccCCDddd&apos;,lambda c: c.upper()):... print(k,list(word))...A [&apos;A&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;]B [&apos;B&apos;, &apos;b&apos;, &apos;B&apos;, &apos;b&apos;, &apos;b&apos;]C [&apos;c&apos;, &apos;c&apos;, &apos;c&apos;, &apos;C&apos;, &apos;C&apos;]D [&apos;D&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;] 挑选规则是通过函数完成的,只要作用于函数的两个元素返回的值相等,就被认为是在一组的,函数返回值作为组的key,忽略大小写分组,就可以让”A”和”a”返回相同的值key. itertools模块提供的函数,全部都是处理迭代的,返回的是Iterator,只有用for进行迭代时才能正确的计算.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(七)]]></title>
      <url>%2F2017%2F04%2F09%2FPython%E5%AD%A6%E4%B9%A0%E4%B8%83%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 常用的内建模块Python内置了许多有用的模块,无需额外安装和配置,可以直接使用. datetime它是Python处理如期和时间的标准库. 获取当前日期和时间: 1234567&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now = datetime.datetime()&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; print(now)2017-04-06 16:35:16.378296&gt;&gt;&gt; print(type(now))&lt;class &apos;datetime.datetime&apos;&gt; 解释:datetime是一个模块,导入的是这个模块中的datetime类,如果仅仅是 import datetime,需要使用全类名,datetime.datetime. datetime.now()是当前的时间和日期,类型是datetime类型. 获取指定的时间和日期: 1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; zd = datetime(2017,4,1,9,50)&gt;&gt;&gt; print(zd)2017-04-01 09:50:00 datetime转换为timestamp首先,什么是timestamp?通常把1970年1月1日,00:00:00 UTC+00:00时区的时刻称为epoch time,记做0,把当前时间相对于epoch time的秒数,叫做timestamp. 直接调用timestamp()方法,就可以获取当前时间的timestamp: 123456789&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; zd = datetime(2017,4,1,9,50)&gt;&gt;&gt; zd.timestamp()1491011400.0timestamp转为datetime:&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; time = 1491011400.0&gt;&gt;&gt; print(datetime.fromtimestamp(time))2017-04-01 09:50:00 timestamp是一个浮点数,没有时区的概念,datetime是有时区的,这里只是对时间进行转换. 2017-04-01 09:50:00 实际上相当于 2017-04-01 09:50:00 UTC+8:00 timestamp直接转换为UTC时区标准时间: 1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; time = 1491011400.0&gt;&gt;&gt; print(datetime.utcfromtimestamp(time))2017-04-01 01:50:00 本地时区为东8区,比UTC时区差了8小时. str转换为datetime将字符串类型的日期和时间,转换为datetime,调用datetime.strptime()方法和一个日期时间的格式化字符串: 1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; da = datetime.strptime(&apos;2022-4-1 13:28:30&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;)&gt;&gt;&gt; print(da)2022-04-01 13:28:30 这个字符串规定了日期和时间的格式,参考Python文档 转化后的datetime是没有时区信息的. datetime转化为str将一个datetime对象转化为字符串,通过strftime()方法实现,和一个格式化日期和时间的字符串: 1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; da = datetime.strptime(&apos;2022-4-1 13:28:30&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;)&gt;&gt;&gt; print(da.strftime(&apos;%a,%b %d %H:%M&apos;))Fri,Apr 01 13:28 时间的加减计算datetime加减计算,就是把datetime往后或向前计算,得到新的datetime,加减可以直接用 + 和 - 运算符,需要导入timedelta. 12345678910&gt;&gt;&gt; from datetime import datetime,timedelta&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2017, 4, 6, 18, 19, 44, 769642)&gt;&gt;&gt; now + timedelta(hours=10)datetime.datetime(2017, 4, 7, 4, 19, 44, 769642)&gt;&gt;&gt; now - timedelta(days = 2)datetime.datetime(2017, 4, 4, 18, 19, 44, 769642)&gt;&gt;&gt; now +timedelta(days=33,hours=12)datetime.datetime(2017, 5, 10, 6, 19, 44, 769642) timedetla()方法可以算出,前后几天的日期和时间. 本地时间转换为UTC时间本地时间是指带有时区信息的时间,北京时间为UTC+8:00时区的时间,UTC时间是指UTC+0:00时区的时间. datetime类型有tzinfo时区属性,默认为None,无法区分这个datetime是哪个时区的时间,可以强行设置一个时区. 123456789&gt;&gt;&gt; from datetime import datetime, timezone, timedelta&gt;&gt;&gt; tz = timezone(timedelta(hours=8))&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2017, 4, 6, 18, 42, 9, 954572)&gt;&gt;&gt; ndt = now.replace(tzinfo=tz)&gt;&gt;&gt; ndtdatetime.datetime(2017, 4, 6, 18, 42, 9, 954572, tzinfo=datetime.timezone(datetime.timedelta(0, 28800))) 时区转化通过utcnow()拿到当前的UTC时间,转转换为任意时区时间: 123456&gt;&gt;&gt; utc_da = datetime.utcnow().replace(tzinfo=timezone.utc)&gt;&gt;&gt; print(utc_da)2017-04-06 10:50:16.899424+00:00&gt;&gt;&gt; bd_da = utc_da.astimezone(timezone(timedelta(hours=8)))&gt;&gt;&gt; print(bd_da)2017-04-06 18:50:16.899424+08:00 通过带有时区的datetime,调用astimezone()方法,可以转换到任意时区. datetime表示的时间需要时区信息才能确定一个特定的时间,否则只能视为本地时间. 要存储datetime的话,最好是将datetime转换为timestamp来存储,timestamp的值与时区没有关系. 练习假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp： 12345678from datetime import datetime, timezone, timedeltadef to_timestamp(dt_str,tz_str): i = datetime.strptime(dt_str,&apos;%Y-%m-%d %H:%M:%S&apos;) tz = tz_str[3:-3] dt = i.replace(tzinfo=timezone(timedelta(hours=int(tz)))) return dt.timestamp()print(to_timestamp(&apos;2015-6-1 08:10:30&apos;, &apos;UTC+7:00&apos;)) collections是Python内置的集合模块,提供了一些集合类. namedtuple它是一个函数,用来创建自定义的tuple对象,规定了tuple元素的个数,并且可以用属性而不是索引来引用tuple的某个元素. 123456789&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Name = namedtuple(&apos;Name&apos;,[&apos;fn&apos;,&apos;ln&apos;])&gt;&gt;&gt; me = Name(&apos;snow&apos;,&apos;lu&apos;)&gt;&gt;&gt; meName(fn=&apos;snow&apos;, ln=&apos;lu&apos;)&gt;&gt;&gt; me.fn 通过属性引用元素&apos;snow&apos;&gt;&gt;&gt; me.ln 通过属性引用元素&apos;lu&apos; 还可以验证创建的Name是不是tuple对象: 1234&gt;&gt;&gt; isinstance(me,Name)True&gt;&gt;&gt; isinstance(me,tuple)True deque是为了高效实现插入和删除操作的双向列表,使用list存储数据时,由于list是线性存储,数据量大的时候,插入和删除的效率很低. 123456789101112&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&gt;&gt;&gt; q.append(&apos;x&apos;)&gt;&gt;&gt; qdeque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;x&apos;])&gt;&gt;&gt; q.appendleft(&apos;o&apos;)&gt;&gt;&gt; qdeque([&apos;o&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;x&apos;])&gt;&gt;&gt; q.popleft()&apos;o&apos;&gt;&gt;&gt; qdeque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;x&apos;]) deque还支持appendleft()和popleft()方法,更方便的从开始位置插入和删除. defaultdict在使用defaultdict时候,如果key不存在,可以返回一个默认值,而使用dict时,如果key不存在,会报错KeyError. 12345678910&gt;&gt;&gt; from collections import defaultdict&gt;&gt;&gt; d = defaultdict(lambda:&apos;N/A&apos;)&gt;&gt;&gt; d[&apos;key&apos;] = &apos;abc&apos;&gt;&gt;&gt; d[&apos;key&apos;]&apos;abc&apos;&gt;&gt;&gt; d[&apos;x&apos;] = &apos;ssss&apos;&gt;&gt;&gt; d[&apos;x&apos;]&apos;ssss&apos;&gt;&gt;&gt; d[&apos;y&apos;]&apos;N/A&apos; defaultdict和dict的区别就是如果key不存在就返回默认值,其他的和dict一样. OrderedDict在使用dict时候,如果想要保持key的顺序,就可以使用OrderedDict. 12345678910&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; d = dict([(&apos;a&apos;,2),(&apos;b&apos;,1),(&apos;c&apos;,4)])&gt;&gt;&gt; d&#123;&apos;c&apos;: 4, &apos;b&apos;: 1, &apos;a&apos;: 2&#125;&gt;&gt;&gt; od = OrderedDict([(&apos;a&apos;,2),(&apos;b&apos;,1),(&apos;c&apos;,4)])&gt;&gt;&gt; odOrderedDict([(&apos;a&apos;, 2), (&apos;b&apos;, 1), (&apos;c&apos;, 4)])&gt;&gt;&gt; oo = OrderedDict(d)&gt;&gt;&gt; ooOrderedDict([(&apos;c&apos;, 4), (&apos;b&apos;, 1), (&apos;a&apos;, 2)]) 需要注意的是,OrderedDict的key是按照插入的顺序排列,不是key本身的顺序. OrderedDict可以实现先进先出的dict,当容量超出限制时,先删除最早插入的Key Counter它是一个简单的计数器,可以统计字符出现的个数: 1234567&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; cc = Counter()&gt;&gt;&gt; for ch in &apos;language&apos;:... cc[ch] = cc[ch]+1...&gt;&gt;&gt; ccCounter(&#123;&apos;g&apos;: 2, &apos;a&apos;: 2, &apos;n&apos;: 1, &apos;e&apos;: 1, &apos;l&apos;: 1, &apos;u&apos;: 1&#125;) Counter是dict的一个子类 12&gt;&gt;&gt;isinstance(cc,dict)True base64Base64是一种用64个字符来表示任意二进制数据的方法. 通常再用记事本打开exe,jpg,pdf等文件时,会看到一堆乱码,这是因为二进制文件中包含很多无法显示和打印的字符,如果要让记事本这样的文本处理软件能够处理二进制数据,就需要一个二进制到字符串的转换方法,Base64就是一种常见的二进制编码的方法 首先准备一个含有64个字符的数组 1[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, ... &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, ... &apos;0&apos;, &apos;1&apos;, ... &apos;+&apos;, &apos;/&apos;] 然后对二进制数据进行处理,没3个字节一组,一共是3*8=24bit(一个字节,8个bit), 化为4组,每组刚好是6个bit. 然后,得到4个数字作为索引,查表,获得相应的4个字符,就是编码后的字符串. Base64会把3字节的二进制数据编码为4字节的文本数据,长度增加33%,好处是编码后的文本数据可以在邮件正文,网页等直接显示. 如果要编码的数据不是3的倍数,最后会有剩余,Base64会用\x00字节在末尾补足后,再在编码的末尾加上1个或2个=号,表示补了多少字节,解码时候,会自动去掉. 12345&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(b&apos;binary\x00string&apos;)b&apos;YmluYXJ5AHN0cmluZw==&apos;&gt;&gt;&gt; base64.b64decode(b&apos;YmluYXJ5AHN0cmluZw==&apos;)b&apos;binary\x00string&apos; 标准的Base64编码后可能会出现字符 + 和 / ,在URL中不能直接作为参数. urlsafe的base64编码可以把字符 + 和 / 分别变成 - 和 _ 123456&gt;&gt;&gt; base64.b64encode(b&apos;i\xb7\x1d\xfb\xef\xff&apos;)b&apos;abcd++//&apos;&gt;&gt;&gt; base64.urlsafe_b64encode(b&apos;i\xb7\x1d\xfb\xef\xff&apos;)b&apos;abcd--&apos;&gt;&gt;&gt; base64.urlsafe_b64decode(&apos;abcd--&apos;)b&apos;i\xb7\x1d\xfb\xef\xff&apos; Base64是一种通过查表的编码方法,不能用于加密,即使使用自定义的编码表也不行. Base64适用于小段内的编码,如:数字证书签名,Cookie的内容. 由于 = 字符也可能出现在Base64编码中,但 = 在URL,Cookie里面会造成歧义,所以,很多Base64编码后会把 = 去掉. 因为Base64是把3个字节变为4个字节,Base64编码的长度是4的倍数,因此,需要加上 = 把Base64字符串的长度变为4的倍数,就可以正常解码了.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(六)]]></title>
      <url>%2F2017%2F04%2F01%2FPython%E5%AD%A6%E4%B9%A0%E5%85%AD%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 进程VS线程多进程和多线程是实现多任务最常用的两种方式.实现多任务,通常会设计Master-Worker模式,Master负责分配任务,worker负责执行任务. 多任务环境下,就是一个Master,多个Worker. 如果用多进程实现Master-Worker,那主线程就是Master,其他线程就是Worker. 如果用多线程实现Master-Worker,那主线程是Master,其他线程就是Worker. 多进程的优势:稳定性高,一个子进程崩溃了,也不会影响其他进程.(主进程崩溃了,其他进程也就挂掉了,由于主进程主要负责分配任务,所以崩溃的几率很低). 多进程的缺点:创建进程的代价大,在Windows下创建进程开销巨大.操作系统同时运行的进程数也是有限的,如果有上千个进程在运行,操作系统调度都有问题. 多线程的优势就是比多进程快一点,这个一点可以忽略不计. 最大的缺点就是,一旦一个线程挂掉了,可能会导致其他线程的崩溃.因为所有线程共享进程的内存. 在Windows系统下多线程的效率要比多进程要高. 线程切换无论是多进程还是多线程,只要数量达到一定上限,效率都会下降.如果有几千个任务同时进行,操作系统就把主要的精力花费在了切换任务上,没有多少时间执行任务. 计算密集型和IO密集型是否考虑多任务,还要考虑任务的类型.可以把任务分为计算密集型和IO密集型 . 计算密集型任务的特点是要进行大量的计算,消耗CPU资源,靠的是CPU的运算能力,虽然可以用多任务完成,但任务越多,花费在切换任务的时间就越多,CPU的执行效率就会下降.要想有效的利用CPU,在此类型的多任务下,同时进行的数量应等于CPU的核心数.还有,代码的运行效率也很重要,推荐用c语言编写计算密集型任务. IO密集型,主要涉及到网络、磁盘IO任务,这类任务的特点就是占用CPU资源很少,主要都在等待IO操作的完成,(因为IO速度低于CPU和内存的速度).对于此类型任务,任务越多,CPU效率越高,也有上限值.由于IO密集型任务把大部分时间花费在IO上,在CPU的时间很少,所以,对于此类任务,最合适的语言就是开发效率最高(代码量最少)的语言,首选脚本语言. 异步IO由于CPU和IO之间存在巨大的速度差异,一个任务执行的大部分时间都在等待IO操作,单进程单线程模型会导致别的任务无法并行执行,因此,才需要多进程或多线程模型来支持多任务并发执行. 充分利用操作系统提供的异步IO支持,就可以用单进程单线程模型来执行多任务,这种叫事件驱动模型 对于Python,单线程的异步编程模型称为协程,有了它,就可以基于事件驱动编写高效的多任务程序. 分布式进程Thread和Process中,优选Process,因为Process更稳定,而且还可以分布到多台机器上,而Thread只能分布到同一台机器的多个CPU上. Python的multiprocessing模块不但支持多进程,managers子模块还支持把多进程分布到多台机器上,一个服务进程可以作为调度者,将任务分布到其他多个线程中 ,依靠网络通信. managers模块封装很好,不必了解网络通信的细节,就可以编写分布式多进程程序. 现有一个通过Queue通信的多进程程序在同一台机器上运行,由于, 处理任务的进程任务越来越繁重,想把发送任务的进程和处理任务的进程分布到两台机器上. 分布式进程的方法就是,通过managers模块把Queue通过网络暴露出去,就可以让其他机器的进程访问Queue了. 服务进程,负责启动Queue,把Queue注册到网络上,然后向Queue写入任务: 1234567891011121314151617181920212223242526272829303132333435import random, time, queuefrom multiprocessing.managers import BaseManager# 发送任务的队列:task_queue = queue.Queue()# 接收结果的队列:result_queue = queue.Queue()# 从BaseManager继承的QueueManager:class QueueManager(BaseManager): pass# 把两个Queue都注册到网络上, callable参数关联了Queue对象:QueueManager.register(&apos;get_task_queue&apos;, callable=lambda: task_queue)QueueManager.register(&apos;get_result_queue&apos;, callable=lambda: result_queue)# 绑定端口5000, 设置验证码&apos;abc&apos;:manager = QueueManager(address=(&apos;&apos;, 5000), authkey=b&apos;abc&apos;)# 启动Queue:manager.start()# 获得通过网络访问的Queue对象:task = manager.get_task_queue()result = manager.get_result_queue()# 放几个任务进去:for i in range(10): n = random.randint(0, 10000) print(&apos;Put task %d...&apos; % n) task.put(n)# 从result队列读取结果:print(&apos;Try get results...&apos;)for i in range(10): r = result.get(timeout=10) print(&apos;Result: %s&apos; % r)# 关闭:manager.shutdown()print(&apos;master exit.&apos;) 运行期间有出现错误:PermissionError: [WinError 5] 拒绝访问. 更改后的task_master.py的代码,运行正常: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import random, time, queuefrom multiprocessing.managers import BaseManagerfrom multiprocessing import freeze_support# 发送任务的队列:task_queue = queue.Queue()# 接收结果的队列:result_queue = queue.Queue()# 从BaseManager继承的QueueManager:class QueueManager(BaseManager): pass def return_task_queue(): global task_queue return task_queue def return_result_queue(): global result_queue return result_queue def reg(): # 把两个Queue都注册到网络上, callable参数关联了Queue对象 QueueManager.register(&apos;get_task_queue&apos;,callable=return_task_queue) QueueManager.register(&apos;get_result_queue&apos;, allable=return_result_queue) # 绑定端口5000, 设置验证码&apos;abc&apos;: manager = QueueManager(address=(&apos;127.0.0.1&apos;, 5000), authkey=b&apos;abc&apos;) # 启动Queue: manager.start() # 获得通过网络访问的Queue对象: task = manager.get_task_queue() result = manager.get_result_queue() # 放几个任务进去: for i in range(10): n = random.randint(0, 10000) print(&apos;Put task %d...&apos; % n) task.put(n) # 从result队列读取结果: print(&apos;Try get results...&apos;) for i in range(10): r = result.get(timeout=10) print(&apos;Result: %s&apos; % r) # 关闭: manager.shutdown() print(&apos;master exit.&apos;)if name == &apos;main&apos;: freeze_support() reg() 在一台机器上写多进程程序时,创建的Queue可以直接拿来用,但在分布式多进程环境下,添加任务到Queue不能对原始的task_queue进行操作,必须通过manager.get_task_queue()获得的Queue接口添加. 任务进程,负责处理任务: 123456789101112131415161718192021222324252627282930313233import time, sys, queuefrom multiprocessing.managers import BaseManager# 创建类似的QueueManager:class QueueManager(BaseManager): pass# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:QueueManager.register(&apos;get_task_queue&apos;)QueueManager.register(&apos;get_result_queue&apos;)# 连接到服务器，也就是运行task_master.py的机器:server_addr = &apos;127.0.0.1&apos;print(&apos;Connect to server %s...&apos; % server_addr)# 端口和验证码注意保持与task_master.py设置的完全一致:m = QueueManager(address=(server_addr, 5000), authkey=b&apos;abc&apos;)# 从网络连接:m.connect()# 获取Queue的对象:task = m.get_task_queue()result = m.get_result_queue()# 从task队列取任务,并把结果写入result队列:for i in range(10): try: n = task.get(timeout=1) print(&apos;run task %d * %d...&apos; % (n, n)) r = &apos;%d * %d = %d&apos; % (n, n, n*n) time.sleep(1) result.put(r) except Queue.Empty: print(&apos;task queue is empty.&apos;)# 处理结束:print(&apos;worker exit.&apos;) 如果运行task_worker.py期间出现ConnectionRefusedError: [WinError 10061]由于目标计算机积极拒绝,请把你的真实的IP地址替换掉127.0.0.1 当启动服务进程task_master.py文件时的运行结果: 1234567891011Put task 7762...Put task 1014...Put task 5055...Put task 2348...Put task 1738...Put task 1615...Put task 6544...Put task 419...Put task 1959...Put task 7894...Try get results... 然后再运行任务进程take_worker.py文件,结果: 1234567891011Connect to server 127.0.0.1...run task 7762 * 7762...run task 1014 * 1014...run task 5055 * 5055...run task 2348 * 2348...run task 1738 * 1738...run task 1615 * 1615...run task 6544 * 6544...run task 419 * 419...run task 1959 * 1959...run task 7894 * 7894... 然后,服务进程take_master.py就会跟着输出: 1234567891011Result: 7762 * 7762 = 60248644Result: 1014 * 1014 = 1028196Result: 5055 * 5055 = 25553025Result: 2348 * 2348 = 5513104Result: 1738 * 1738 = 3020644Result: 1615 * 1615 = 2608225Result: 6544 * 6544 = 42823936Result: 419 * 419 = 175561Result: 1959 * 1959 = 3837681Result: 7894 * 7894 = 62315236master exit. queue对象存储在task_master.py进程中: Queue能通过网络访问,是通过QueueManager实现的,它管理的不只是一个Queue,要给每个Queue的网络调用接口起个名字,比如:get_task_queue. authkey,是为了保证两台机器正常通信,不被其他机器恶意干扰.就像一个暗号,如果两边的暗号对不上,那就连接不上了. Python的分布式进程接口简单,封装良好,适合需要把繁重任务分布到多台机器的环境下.Queue的作用是用来传递任务和接收结果,每个任务的描述数据量要尽量小. 正则表达式正则表达式是一种用来匹配字符串的工具.设计思想是用一种描述性语言给字符串定义一个规则,凡是符合规则的字符串,就可以认为匹配. 字符集合 说明 \w 可以匹配任何一个字母或者数字或者下划线 \W W大写，可以匹配任何一个字母或者数字或者下划线以外的字符 \s 可以匹配空格、制表符、换页符等空白字符的其中任意一个 \S S大写，可以匹配任何一个空白字符以外的字符 \d 可以匹配任何一个 0~9 数字字符 \D D大写，可以匹配任何一个非数字字符 [ ] 用来自定义能够匹配 ‘多种字符’ 的表达式。要匹配中括号，请使用 “[“ 和 “]“ { } 修饰匹配次数的符号。要匹配大括号，请使用 “{“ 和 “}“ . 匹配除了换行符（\n）以外的任意一个字符。要匹配小数点本身，请使用 “.“ ^ 匹配输入字符串的开始位置。 $ 匹配输入字符串的结尾位置。 + 修饰匹配次数为至少 1 次。 ( ) 标记一个子表达式的开始和结束位置。 * 修饰匹配次数为 0 次或任意次。 python字符串本身也用\转义,使用Python的r前缀,就不用考虑转义了. 12345&gt;&gt;&gt; import re&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;-\d&#123;3,8&#125;&apos;, &apos;010-12345&apos;)&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;\-\d&#123;3,8&#125;&apos;, &apos;010 12345&apos;)&gt;&gt;&gt; match()方法,如果匹配成功,就返回一个Match对象,如果不匹配,返回None. 切分字符串单个空格分割: 12&gt;&gt;&gt; re.split(r&apos;\s+&apos;, &apos;a b c&apos;)[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 多个空格,符号,切割: 12&gt;&gt;&gt; re.split(r&apos;[\s\,\;]+&apos;, &apos;a,b;; c d&apos;)[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] 分组可以用()来进行分组 123456789&gt;&gt;&gt; m = re.match(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;, &apos;010-12345&apos;)&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;&gt;&gt;&gt; m.group(0)&apos;010-12345&apos;&gt;&gt;&gt; m.group(1)&apos;010&apos;&gt;&gt;&gt; m.group(2)&apos;12345&apos; ^(\d{3})-(\d{3,8})$ 定义了两个组,可以直接分出,区号和电话号码.可以用group()方法取出分组,group(0)代表要匹配的本身的字符串,group(1)就是第一个子字符串,以此类推. 贪婪匹配正则表达式默认的是贪婪匹配,就是匹配尽可能多的字符. 12&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups()(&apos;102300&apos;, &apos;&apos;) ^(\d+)(0*)$ 的第一个分组\d+把所有的0都匹配了,后面的0*只匹配了空字符. 加个？来使用非贪婪匹配 12&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups()(&apos;1023&apos;, &apos;00&apos;) 很厉害的正则表达式在线匹配网站 re模块python提供的模块,包含所有正则表达式的功能. Python官方re模块链接 一个email的匹配:(不一定准确) 123456&gt;&gt;&gt; import re&gt;&gt;&gt; c = re.compile(r&apos;^(\w&#123;3,11&#125;\@&#123;1&#125;\w&#123;3,8&#125;.\w&#123;3&#125;)&apos;)&gt;&gt;&gt; c.match(&apos;snowluliang@gmalil.com&apos;)&lt;_sre.SRE_Match object; span=(0, 22), match=&apos;snowluliang@gmalil.com&apos;&gt;&gt;&gt;&gt; c.match(&apos;18651528973@163.com&apos;)&lt;_sre.SRE_Match object; span=(0, 19), match=&apos;18651528973@163.com&apos;&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(五)]]></title>
      <url>%2F2017%2F03%2F31%2FPython%E5%AD%A6%E4%B9%A0%E4%BA%94%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 多进程和多线程线程是最小的执行单元,真正的多进程是需要多核CPU支持才行,单核CPU之所以能执行多进程,是因为CPU的执行速度非常之快,在多个进程中交替执行,看起来像是多进程,实际上还是单进程.进程中包含有许多线程,像word之类的编辑文档,既需要记录用户输入的内容,又需要随时保存,打印等服务. 多进程Python中os模块封装了常见的系统调用,包括fork()方法,可以在Python中创建子进程,但是在Windows下,调用fork() 方法时,却没有… 1234567&gt;&gt;&gt; import os&gt;&gt;&gt; print(&apos;Process (%s) start...&apos; % os.getpid())Process (7088) start...&gt;&gt;&gt; pid = os.fork()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: module &apos;os&apos; has no attribute &apos;fork&apos; Windows上就没有办法编写多进程的程序了嘛?当然不是. 因为Python是跨平台的,multiprocessing模块就是跨平台的多进程模块. 123456789101112from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print(&apos;Run child process %s (%s)...&apos; % (name, os.getpid()))if name==&apos;main&apos;: print(&apos;Parent process %s.&apos; % os.getpid()) p = Process(target=run_proc, args=(&apos;test&apos;,)) print(&apos;Child process will start.&apos;) p.start() p.join() print(&apos;Child process end.&apos;) 执行结果: 1234Parent process 6288.Child process will start.Run child process test (9012)...Child process end. 创建子进程时,先创建Process实例,传入函数和函数的参数,挑用start方法启动,join方法是让子进程执行完毕后再继续向下执行,通常用于进程间同步. Pool如果需要大量的子进程,可以用进程池批量创建子进程: 123456789101112131415161718from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print(&apos;Run task %s (%s)...&apos; % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print(&apos;Task %s runs %0.2f seconds.&apos; % (name, (end - start)))if __name__ == &apos;__main__&apos;: print(&apos;Parent process %s.&apos; % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print(&apos;Waiting for all subprocesses done...&apos;) p.close() p.join() print(&apos;All subprocesses done.&apos;) 执行结果: 12345678910111213Parent process 5524.Waiting for all subprocesses done...Run task 0 (2856)...Run task 1 (7840)...Run task 2 (8688)...Run task 3 (9180)...Task 1 runs 0.75 seconds.Run task 4 (7840)...Task 4 runs 0.08 seconds.Task 0 runs 1.36 seconds.Task 3 runs 1.59 seconds.Task 2 runs 2.82 seconds.All subprocesses done. 对Pool对象调用join()方法会等待所有的子进程,调用之前必须先调用close()方法,调用close()之后就不能继续添加新的Process了. 子进程subprocess,可以启动一个子进程,然后控制其输入和输出. 12345678910111213&gt;&gt;&gt; import subprocess&gt;&gt;&gt; print(&apos;$nslookup www.python.org&apos;)$nslookup www.python.org&gt;&gt;&gt; r = subprocess.call([&apos;nslookup&apos;,&apos;www.python.org&apos;])服务器: UnKnownAddress: 192.168.0.1非权威应答:名称: python.map.fastly.netAddresses: 2a04:4e42:12::223 151.101.76.223Aliases: www.python.org&gt;&gt;&gt; print(&apos;Exit code:&apos;,r)Exit code: 0 进程间通信进程间需要通信,操作系统提供了很多机制实现进程间通信,Python的multiprocessing模块包装了底层的机制,提供了Queue,Pipes等方式交换数据. 12345678910111213141516171819202122232425262728from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): print(&apos;Process to write: %s&apos; % os.getpid()) for value in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: print(&apos;Put %s to queue...&apos; % value) q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): print(&apos;Process to read: %s&apos; % os.getpid()) while True: value = q.get(True) print(&apos;Get %s from queue.&apos; % value)if name==&apos;main&apos;: # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 启动子进程pr，读取: pr.start() # 等待pw结束: pw.join() # pr进程里是死循环，无法等待其结束，只能强行终止: pr.terminate() 结果有报错: 12345678Traceback (most recent call last): File &quot;queue.py&quot;, line 21, in &lt;module&gt; q = Queue() File&quot;C:\Users\snow\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py&quot;,line 100, in Queue from .queues import Queue File&quot;C:\Users\snow\AppData\Local\Programs\Python\Python35\lib\multiprocessing\queues.py&quot;, line 20, in &lt;module&gt; from queue import Empty, FullImportError: cannot import name &apos;Empty&apos; 明白了错误的原因,在命名的时候queue.py文件名会和要导入的模块有冲突,改成没有冲突的就可以了,比如:qu.py.结果: 123456789D:\Python&gt;python qu.pyProcess to write: 6156Put A to queue...Process to read: 7052Get A from queue.Put B to queue...Get B from queue.Put C to queue...Get C from queue. 由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去,如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了. 实现跨平台多进程,使用multiprocessing模块,进程间通信,用Queu,Pipes. 多线程多任务可以由多进程来完成,也可以用多线程来完成.一个进程是由多条线程组成的,一个进程至少有一个线程. Python中提供了两个模块,_thread和threading,_thread是低级模块,threading是高级模块,对_thread进行了封装,一般情况下,用threading. 启动一个线程就是把一个函数传入并创建Thread实例,然后调用start()方法: 123456789101112131415import time, threading# 新线程执行的代码:def loop(): print(&apos;thread %s is running...&apos; % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print(&apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n)) time.sleep(1) print(&apos;thread %s ended.&apos; % threading.current_thread().name)print(&apos;thread %s is running...&apos; % threading.current_thread().name)t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)t.start()t.join()print(&apos;thread %s ended.&apos; % threading.current_thread().name) 执行结果: 123456789thread MainThread is running...thread LoopThread is running...thread LoopThread &gt;&gt;&gt; 1thread LoopThread &gt;&gt;&gt; 2thread LoopThread &gt;&gt;&gt; 3thread LoopThread &gt;&gt;&gt; 4thread LoopThread &gt;&gt;&gt; 5thread LoopThread ended.thread MainThread ended. 进程启动都会默认启动一个线程,称之为主线程,主线程的实例叫MainThread,在Python的threading模块中的 current_thread()函数,它永远返回当前线程的实例,子线程的名字在创建时指定,如果没有为子线程命名,Python会自动给线程命名Thread1,Thread2… Lock就是锁的意思.多线程和多进程最大的区别,就是在多进程中,同一变量,每个进程都有拷贝一份,互不影响.在多线程中,所有变量都由所有线程共享,任何 一个变量都可以被任何一个线程修改.所以,线程间共享数据最大的危险在于多个线程同时修改一个变量,导致变量内容错误. 123456789101112131415161718import time, threading# 假定这是你的银行存款:balance = 0def change_it(n): # 先存后取，结果应该为0: global balance balance = balance + n balance = balance - ndef run_thread(n): for i in range(100000): change_it(n)t1 = threading.Thread(target=run_thread, args=(5,))t2 = threading.Thread(target=run_thread, args=(8,))t1.start()t2.start()t1.join()t2.join()print(balance) 执行结果可能每次都不一样: 12345678910D:\Python&gt;python lock.py0D:\Python&gt;python lock.py5D:\Python&gt;python lock.py0D:\Python&gt;python lock.py-8D:\Python&gt;python lock.py0 线程的调度是由操作系统决定的,当t1,t2交替执行时候,结果可能会变掉 x为局部变量,当每个线程都有自己的变量x时: 123456789t1: x1 = balance + 5 # x1 = 0 + 5 = 5t1: balance = x1 # balance = 5t1: x1 = balance - 5 # x1 = 5 - 5 = 0t1: balance = x1 # balance = 0t2: x2 = balance + 8 # x2 = 0 + 8 = 8t2: balance = x2 # balance = 8t2: x2 = balance - 8 # x2 = 8 - 8 = 0t2: balance = x2 # balance = 0结果 balance = 0 当t1和t2交替执行时候: 12345678910初始值 balance = 0t1: x1 = balance + 5 # x1 = 0 + 5 = 5t2: x2 = balance + 8 # x2 = 0 + 8 = 8t2: balance = x2 # balance = 8t1: balance = x1 # balance = 5t1: x1 = balance - 5 # x1 = 5 - 5 = 0t1: balance = x1 # balance = 0t2: x2 = balance - 8 # x2 = 0 - 8 = -8t2: balance = x2 # balance = -8结果 balance = -8 为了防止变量的内容被多个线程修改错乱,既可以为线程加上锁(Lock),在change_it()方法加上锁,当前线程就获得了锁,其他线程就不能调用change_it()方法,必须等待锁的释放之后,才能对变量进行修改: 1234567891011balance = 0lock = threading.Lock()def run_thread(n): for i in range(100000): #先要获取锁 lock.acquire() try: change_it(n) finally: #改完了一定要释放锁 lock.release() 通过threading.Lock()来创建一个锁,加上锁之后,一定要记得通过lock.release()释放锁,否则,会导致线程为死线程. Python解释器在执行代码时,都会为每个线程加上一个GIL锁(Global Interpreter Lock),线程在执行前,必须先获得GIL锁,然后,每执行100条字节码,解释器就会自动释放GIL锁,让其他线程有机会执行,GIL全局锁,实际上把所有线程的执行代码都给加上了锁.所以,多线程在Python中只能交替执行,即使100个线程泡在100核CPU上,也只能用1核. 所以,在Python中,可以使用多线程,但不要期望有效利用多核,在Python中虽然不能利用多线程实现多核任务,但可以通过多进程实现多核任务,多个Python进程有各自独立的GIL锁,互不影响. 多线程并发在Python中,不会发生, ThreadLocal在多线程环境下,每个线程都有自己的数据,一个线程使用自己的局部变量比使用全局变量好,因为局部变量只有线程自己能看到,不会影响其他线程,而全局变量的修改必须加锁. 当你在函数调用局部变量: 12345678910111213def process_student(name): std = Student(name) # std是局部变量，但是每个函数都要用它，因此必须传进去： do_task1(std) do_task2(std)def do_task1(std): do_subtask1(std) do_subtask2(std) def do_task2(std): do_subtask2(std) do_subtask2(std) 这样的层级传递很麻烦,使用ThreadLocal时,可以简化这样的调用: 1234567891011121314151617181920import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student(): # 获取当前线程关联的student: std = local_school.student print(&apos;Hello, %s (in %s)&apos; % (std, threading.current_thread().name))def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student() t1 = threading.Thread(target= process_thread,args=(&apos;Alice&apos;,),name=&apos;Thread-A&apos;)t2 = threading.Thread(target= process_thread,args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)t1.start()t2.start()t1.join()t2.join() 输出结果: 12Hello, Alice (in Thread-A)Hello, Bob (in Thread-B) 使用threading.local()方法来创建一个全局的ThreadLocal对象–&gt;local_school 每个Thread对它都可以读写student属性,互不影响. 可以把local_school看成是全局变量,local_school.student属性都是线程的局部变量,可以任意读写而且互不干扰,也不用管锁的问题,都由ThreadLocal处理. ThreadLocal最常用的地方是,为每个线程绑定一个数据库连接,HTTP请求,用户身份信息等,这样一个线程的所有调用到的处理函数都可以方便的访问这些资源. ThreadLocal解决了参数在一个线程中各个函数间互相传递的问题.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(四)]]></title>
      <url>%2F2017%2F03%2F27%2FPython%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 IO编程文件读写取在磁盘上读写文件的功能都是由操作系统提供的,现代操作系统不允许一般的程序直接操作磁盘,读写文件就是请求操作系统打开一个文件对象,然后通过操作系统提供的接口从这个文件对象中读取数据(读文件),或者把数据写入文件对象(写文件). 使用Python内置的open()函数,传入文件路径名和标示符,就能打开一个文件,如果文件不存在,会抛出一个IOError,并指出错误出现的地方: 1234&gt;&gt;&gt; f=open(&apos;/Users/michael/notfound.txt&apos;, &apos;r&apos;)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;FileNotFoundError:[Errno 2] No such file or directory: &apos;/Users/michael/notfound.txt&apos; r,表示读取,如果打开成功,read()方法可以读取文件的全部内容,把内容读到内存,用str对象表示,最后要调用close()方法来关闭读取操作,这一步必须有,很重要. 在文件读写的过程中,都有可能发生IOError,后面的close()方法就不会执行了,Python内置的有with语句自动帮我们自动调用close()方法: 12with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f: print(f.read()) read()方法可以读取目标文件的全部内容,这不太保险,如果文件过大,内存容量不够,就挂掉了,如果文件很小的话,这个很方便. read(size)方法可以每次读取多少字节,在不确定文件大小的情况下,反复调用read(size)方法最保险. readline()可以读取一行. readlines()可以读取所有行的内容并按行返回list. 如果是配置文件,这个很方便. 按照需求,选取合适的方法. 二进制文件的读取,如图片,视频,用’rb‘模式打开: 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)&gt;&gt;&gt; f.read()b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节 想要读取特定编码的文件对象,需要在open()函数中传入编码类型encoding: 123&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)&gt;&gt;&gt; f.read()&apos;测试&apos; 如遇到编码不规范的文件,可能会有UnicodeDecodeError. 文件中可能含有非法字符,在open()函数中黑可以传入一个errors参数,表示如果遇到异常如何处理, 1&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;, errors=&apos;ignore&apos;) 文件写入文件写入和文件读取类似,只不过在open()函数中的参数是’w’和’wb’,用来读取文本文件和二进制文件 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)&gt;&gt;&gt; f.close() 用with语句最保险: 12with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f: f.write(&apos;Hello, world!&apos;) 反复调用write()方法,最重要的是还要调用close()方法,这样才能保证,系统把数据全部写入到指定文件中,如果要指定编码类型,只需要在open()函数中传入指定的的编码就可以了. StringIO 是在内存中读写str: 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write(&apos;hello&apos;)5 #字符个数&gt;&gt;&gt; f.write(&apos; &apos;)1&gt;&gt;&gt; f.write(&apos;world!&apos;)6&gt;&gt;&gt; print(f.getvalue())hello world! getvalue()是用于获取写入后的字符串. 读取StringIO和读取文件类似 1234567891011&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;)&gt;&gt;&gt; while True:... s = f.readline()... if s == &apos;&apos;:... break... print(s.strip())...Hello!Hi!Goodbye! BytesIO用于读写二进制数据. 12345&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))6&gt;&gt;&gt; print(f.getvalue())b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 用BytesIO写入的不是str,而是经过编码后的byte字节,读取类似StringIO,先获得BytesIO的对象,进行读取: 1234&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)&gt;&gt;&gt; f.read()b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 操作文件和目录在Python中操作文件和目录的命令都在os模块和os.path模块当中 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.name &apos;nt&apos; 操作系统类型,nt 代表Windows,还有POSIX类型,代表Linux,Unix,或者MacOs. 环境变量: 1&gt;&gt;&gt; os.environ 取得某个环境变量的值: 1&gt;&gt;&gt; os.environ.get(&apos;path&apos;) 当前目录的绝对路径: 1&gt;&gt;&gt; os.path.abspath(&apos;.&apos;) 把两个路径合成一个时: 1os.path.join() 拆分路径: 12&gt;&gt;&gt; os.path.split(&apos;C:/Users/snow/Desktop/22.txt&apos;)(&apos;C:/Users/snow/Desktop&apos;, &apos;22.txt&apos;) 拆分直接得到文件扩展名: 12&gt;&gt;&gt; os.path.splitext(&apos;C:/Users/snow/Desktop/22.txt&apos;)(&apos;C:/Users/snow/Desktop/22&apos;, &apos;.txt&apos;) 合并,拆分路径操作,并不要次文件真实存在,只是对字符串进行操作. 对文件重命名: 1&gt;&gt;&gt;os.rename(&apos;test.txt&apos;, &apos;test.py&apos;) 删掉文件: 1&gt;&gt;&gt;os.remove(&apos;test.py&apos;) shutil模块中有copyfile()函数. 列出当前目录下的所有文件夹: 12&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)][&apos;DLLs&apos;, &apos;Doc&apos;, &apos;include&apos;, &apos;Lib&apos;, &apos;libs&apos;, &apos;Scripts&apos;, &apos;tcl&apos;, &apos;Tools&apos;] 列出所有的.py文件: 123&gt;&gt;&gt; import os&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;][&apos;break.py&apos;, &apos;if.py&apos;, &apos;learning.py&apos;, &apos;secret.py&apos;, &apos;sum.py&apos;, &apos;turtle.py&apos;] 序列化把变量从内存中变成可存储或传输的过程称之为序列化,在Python中叫pickling,序列化之后,就可以把序列化后的内容写入磁盘,或者通过网络传输到别的机器上. 反过来,把序列化之后的对象读到内存中,称为反序列化,unpickling. pickle模块实现序列化: 1234&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&apos;Snow&apos;,age=20,score=88)&gt;&gt;&gt; pickle.dumps(d)b&apos;\x80\x03&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x04\x00\x00\x00Snowq\x02X\x05\x00\x00\x00scoreq\x03KXX\x03\x00\x00\x00ageq\x04K\x14u.&apos; pickle.dumps()方法可以把任意对象序列化成一个bytes,然后,就可以把bytes写入文件,或者,用pickle.dump()直接把对象序列化后写入一个file-like-Object: 123456&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&apos;snow&apos;,age =22,sorce=90)&gt;&gt;&gt; f = open(&apos;33.txt&apos;,&apos;wb&apos;)&gt;&gt;&gt; pickle.dump(d,f)&gt;&gt;&gt; f.close&lt;built-in method close of _io.BufferedWriter object at 0x00000000011AA938&gt; 33.txt中的内容像这样: 12345678003 7d71 0028 5803 0000 0061 6765 71014b16 5805 0000 0073 6f72 6365 7102 4b5a5804 0000 006e 616d 6571 0358 0400 0000736e 6f77 7104 752e 8003 7d71 0028 58030000 0061 6765 7101 4b16 5805 0000 00736f72 6365 7102 4b5a 5804 0000 006e 616d6571 0358 0400 0000 736e 6f77 7104 752e 当把对象从磁盘中读到内存时候,可以先读取一个bytes,然后用pickle.loads()方法反序列化出对象,也可以用pickl.load()方法从一个file-like-Object中直接反序列化出对象, 12345&gt;&gt;&gt; f = open(&apos;33.txt&apos;,&apos;rb&apos;)&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;&apos;age&apos;: 22, &apos;sorce&apos;: 90, &apos;name&apos;: &apos;snow&apos;&#125; pickle只能用于python,不同版本的互不兼容,只能用pickle存储一些不太重要的信息. JSON要在不同编程语言之间传递对象,就要把对象序列化为标准格式,JSON表示的是一个字符串,可以被所有语言读取,可以方便的存储到磁盘或者通过网络传输,可以直接在Web页面读取. JSON类型 Python类型 {} dict [] list “string” str 1234.56 int或float true/false True/False null None python对象转化为JSON: 1234&gt;&gt;&gt; import json&gt;&gt;&gt; d = dict(name=&apos;snow&apos;,age =22,sorce=90)&gt;&gt;&gt; json.dumps(d)&apos;&#123;&quot;age&quot;: 22, &quot;sorce&quot;: 90, &quot;name&quot;: &quot;snow&quot;&#125;&apos; 使用JSON反序列化为Python对象,用loads(),或者load()方法,loads()方法将JSON的字符串反序列化,load()方法将从file-like-Object读取字符串并反序列化: 1234&gt;&gt;&gt; import json&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 22, &quot;sorce&quot;: 90, &quot;name&quot;: &quot;snow&quot;&#125;&apos;&gt;&gt;&gt; json.loads(json_str)&#123;&apos;name&apos;: &apos;snow&apos;, &apos;age&apos;: 22, &apos;sorce&apos;: 90&#125; JSON标准规定JSON编码是UTF-8. Python语言序列化的模块是pickle,想要把序列化更通用,更符合web标准,就可以用JSON.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(三)]]></title>
      <url>%2F2017%2F03%2F25%2FPython%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 面型对象高级编程数据封装,继承和多态只是面向对象编程的3个基础概念 __slots__定义一个Class后,创建一个class实例后,可以给实例绑定任何属性和方法,动态语言的灵活性, 12class Student(object): pass 创建实例,绑定一个属性值: 123&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = &apos;Michael&apos; # 动态给实例绑定一个属性&gt;&gt;&gt; print(s.name)Michael 还可以为其绑定一个方法, 但是,这个方法只对当前实例有效,对其他实例没有效果。 使用 __slots__ 可以为类限定以后添加的属性, 12class Student(object): slots = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称 这样,除了name和age属性之外的属性,都不可以添加了,会报错 1234567&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos; 使用 __slots__ 仅对当前实例有效,对其子类则没有效果,除非在子类中定义 __slots__ 方法 @property@property就是可以让实例的方法当做属性来用,例如:给Screen对象加上width和height属性,以及一个只读属性的resolution, 1234567891011121314151617181920class Screen(object): @property #设置getter方法 def width(self): return self._width @width.setter #设置setter方法 def width(self,value): self._width = value @property #设置getter方法 def height(self): return self._height @height.setter #设置setter方法 def height(self,value): self._height = value @property #没有setter方法,只读属性,通过计算出来的 def resolution(self): return self.width*self.height 测试结果: 12345s = Screen()s.width = 1024 #这里就相当于s.set_widths.height = 768 #这里就相当于s.set_heightprint(s.resolution) 786432 多重继承Python允许使用多重继承,例如:狗是一种会跑的,食肉的,哺乳型动物,就可以继承自定义的 会跑的动物(Runnable),食肉的(Carnivorous),哺乳型(Mammal),动物(Animal)… 12class Dog(Mammal,Animal,Carnivorous): pass 这种模式叫做MixIn,目的是为了给一个类增加多个功能,在设计类的时候,优先考虑通过多重继承来组合多个MixIn的功能,而不是设计复杂层次的继承关系, Enum枚举类12345678910from enum import Enum, unique@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 @unique用来检查有没有重复值 访问枚举类型 12345678&gt;&gt;&gt; print(Weekday.Tue)Weekday.Tue&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])Weekday.Tue&gt;&gt;&gt; print(Weekday.Tue.value)2&gt;&gt;&gt; print(Weekday(1))Weekday.Mon 可以根据枚举名称引用常量,也可以用value的值获取枚举常量 元类(metalclass)动态语言在函数和类的定义过程中,不是编译时定义的 ,而是运行时动态创建的, 当我们需要创建一个实例时,首先要先定义一个类,然后在创建类的实例,所以顺序就是 –&gt;创建类–&gt;创建实例, 但是创建类的时候呢?这是就是先创建metalclass,在创建类,在创建实例,顺序就是–&gt;创建metalclass–&gt;创建类–&gt;创建类的实例 可以理解为,类就是metalclass的实例, ①它可以拦截类的创建, ②对类进行修改 ③返回修改后的类 详细解释 错误,调试,测试错误处理try…except…finally…错误处理机制 123456789try: print(&apos;try...&apos;) r = 10 / 0 print(&apos;result:&apos;, r)except ZeroDivisionError as e: print(&apos;except:&apos;, e)finally: print(&apos;finally...&apos;)print(&apos;END&apos;) 当try执行代码块出错时候,后续代码将不执行,而是执行except语句中的代码,提示错误的出现,如果finally语句中有代码,再执行其语句中的代码, 1234try...result: 5finally...END 也可以添加多个except语句块,捕获不同错误,还可以加入else语句块, 123456except ValueError as e: print(&apos;ValueError:&apos;, e)except ZeroDivisionError as e: print(&apos;ZeroDivisionError:&apos;, e)else: print(&apos;no error!&apos;) 错误类型和继承关系 try…except..还可以跨越多层级调用,可以减少try..except..代码块的书写 1234567891011def foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar(&apos;0&apos;) except Exception as e: print(&apos;Error:&apos;, e) finally: print(&apos;finally...&apos;) 如果错误没有被捕获,会一直向上抛,直到Python解释器捕获,打印错误信息,程序退出, 出现错误不可怕,不知道错误出现在哪里才可怕,要找到错误出现的地方,出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。 通过logging可以方便的记录错误, 12except Exception as e: logging.exception(e) 抛出错误raise 12345def foo(s): n = int(s) if n==0: raise FooError(&apos;invalid value: %s&apos; % s) return 10 / n 只有在必要的时候才使用自定义的错误类,如果可以用Python内置的错误类,尽量使用内置的错误类, 调试程序调试的方法有: print()直接打印处错误,还需要手动删除 断言assert, 123456def foo(s): n = int(s) assert n != 0, &apos;n is zero!&apos; return 10 / ndef main(): foo(&apos;0&apos;) 表达式 n!=0应该是true,否则,后面的代码会出错,如果断言失败,会抛出AssertionError, 启用Python解释器时候,可以启用-0来关闭断言 1$ python3 -0 err.py logging,它不会抛出错误,可以输出到文件,可以指定记录信息的级别,debug,info,warning,error等, pdb,python自带的调试器, 1234# err.pys = &apos;0&apos;n = int(s)print(10 / n) 启动调试器: 123$ python3 -m pdb err.py&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()-&gt; s = &apos;0&apos; 输入命令n可以单步执行代码, 123456(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()-&gt; n = int(s)(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()-&gt; print(10 / n) 输入 p 变量名 可以查看变量 1234(Pdb) p s&apos;0&apos;(Pdb) p n0 输入q 退出调试 pdb.set_trace(),这个方法也是pdb调试的,但不需要单步执行, 123456# err.pyimport pdbs = &apos;0&apos;n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n) 只需要在可能出现错误的地方,加上pdb.set_trace(),代码执行到此时,会自动进入pdb调试模式,可以用p查看变量,用c继续执行 12345678910$ python3 err.py &gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()-&gt; print(10 / n)(Pdb) p n0(Pdb) cTraceback (most recent call last):File &quot;err.py&quot;, line 7, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero IDE调试,比较好的Python IDE 有PyCharm 单元测试单元测试时对一个类,一个函数或者一个模块正确性检测的测试工作,就是确保一个程序模块的行为符合我们设计的测试用例,在将来进行修改时候,极大可能保证此模块仍然是正确的 文档测试Python内置的 文档测试(doctest) 可以抽取文档中的代码直接运行 doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确 12345678910111213141516171819def fact(n): &apos;&apos;&apos;&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(2)2&gt;&gt;&gt; fact(-1)Traceback (most recent call last):ValueError &apos;&apos;&apos; if n &lt; 1: raise ValueError() if n == 1: return 1 return n * fact(n - 1)if__name__ == &apos;__main__&apos;: import doctest doctest.testmod()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(二)]]></title>
      <url>%2F2017%2F03%2F24%2FPython%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 模块模块最大的好处就是提高了代码的可维护性,避免函数名和包名的冲突, 使用和安装第三方模块先import导入,第三方模块,就能用到数据此模块当中的函数和属性 下载地址 面向对象编程Object Oriented Programming 简称OOP,是一种程序设计思想,OOP把对象作为程序的基本单元,一个对象包含函数和操作函数的方法; 类和实例面向对象最重要的概念类(class)和实例(instance) 1234class Student(object): def init(self, name, score): self.name = name self.score = score init 前后有两个下划线,第一个参数始终是self, 访问限制Class内部有属性和方法,外部可以直接用实例来操作类的属性和方法,隐藏了内部复杂的逻辑, 如果不想让内部属性被外部访问,可以把属性名称前面加上两个下划线__,这样内部属性就变成了私有变量,外部不可访问; 1234class Student(object): def init(self, name, score): self.name = name self.score = score 如果需要对属性变量进行更改或取值,可以给类添加get和set方法,通过,get_name,set_sorce,进行修改; 12345678class Student(object): def get_name(self): return self.__name def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError(&apos;bad score&apos;) 其次, __XXX__ 类似这样前后带有双下划线的变量,不是私有变量,可以随意访问. _XXX 带有一个下划线的变量,视为私有变量,不要轻易访问; 带有双下划线的私有变量一定要从外部访问嘛? 不一定,带有双下划线的私有变量,Python解释器,其实把, __name 变量给成了_Student__name, 所以,还是可以通过,_Student__name 的形式进行访问; 但是,强烈建议不要这么做.因为不同版本的Python解释器可能会把 __name 改成不同的变量; 继承和多态继承最大的好处就是,子类可以拥有父类的全部方法和功能 123class Animal(object): def run(self): print(&apos;Animal is running...&apos;) 123class Dog(Animal): def run(self): print(&apos;Dog is running...&apos;) 123class Cat(Animal): def run(self): print(&apos;Cat is running...&apos;) Animal就是Dog,Cat的父类,Dog,Cat就是Animal的子类,并拥有父类的全部方法 子类和父类中拥有相同run()方法,说明子类run()方法覆盖了父类run()的方法,代码运行时候就会调用 子类的run()方法,这就是继承的另一个好处:多态 当然也可以添加父类没有的方法 判断一个变量是否是某个类型可以用isinstance()判断： 12&gt;&gt;&gt; isinstance(c, Animal)True 继承关系树: 静态语言 vs 动态语言 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者 它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一 个run()方法就可以了： 获取对象信息想要知道该对象是什么类型的 type()方法123456&gt;&gt;&gt; type(123)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; type(&apos;str&apos;)&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; type(None)&lt;type(None) &apos;NoneType&apos;&gt; type返回的是对应的Class类型. 比较两个变量的type类型是否相同: instance()方法先创建变量类型: 123&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky() 判断: 1234&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)True dir()方法想要或去一个对象的所有属性和方法,可以使用dir()方法,返回的是一个包含字符串的list,如: 1&gt;&gt;&gt; dir(&apos;ABC&apos;) 1[&apos;add&apos;, &apos;class&apos;, &apos;contains&apos;, &apos;delattr&apos;, &apos;dir&apos;, &apos;doc&apos;, &apos;eq&apos;, &apos;format&apos;, &apos;ge&apos;, &apos;getattribute&apos;, &apos;getitem&apos;, &apos;getnewargs&apos;, &apos;gt&apos;, &apos;hash&apos;, &apos;init&apos;, &apos;iter&apos;, &apos;le&apos;, &apos;len&apos;, &apos;lt&apos;, &apos;mod&apos;, &apos;mul&apos;, &apos;ne&apos;, &apos;new&apos;, &apos;reduce&apos;, &apos;reduce_ex&apos;, &apos;repr&apos;, &apos;rmod&apos;, &apos;rmul&apos;, &apos;setattr&apos;, &apos;sizeof&apos;, &apos;str&apos;, &apos;subclasshook&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;] 还可以配合,getattr(),setattr()和hasattr()方法来操作属性和方法,如: 123456&gt;&gt;&gt; class MyObject(object):... def init(self):... self.x = 9... def power(self):... return self.x * self.x...&gt;&gt;&gt; obj = MyObject() 然后,测试是否含有属性: 12345678910111213&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？False&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？True&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;19&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;19 如果试图获取不存在的属性,会报错:AttributeError的错误 实例属性和类属性在编写实例属性和类属性的话,尽量不要使用相同的名字,相同名称的实例属性会覆盖掉类属性,如果 删除掉实例属性的话,再用相同名称,访问到的是类属性.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(一)]]></title>
      <url>%2F2017%2F03%2F12%2FPython%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 list:Pytho内置的数据类型列表,list是一种可变有序集合,可以随时添加和删除其中的元素.可添加元素到末尾. 123&gt;&gt;&gt; classmates.append(&apos;Adam&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 也可以指定索引号,添加到指定位置, 123&gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 删除元素: pop()方法 删除末尾元素,也可指定索引删除指定位置pop(i) tuple另外一种有序列表,元组,和list非常相似,但tuple一旦初始化,就不能更改, 代码更安全,能用tuple替代list,就替换掉, 定义一个元素时,例子: 12&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 条件判断1234567&gt;&gt;&gt;age = 20&gt;&gt;&gt;if age &gt;= 6: ... print(&apos;teenager&apos;)...elif age &gt;= 18: ... print(&apos;adult&apos;)...else: ... print(&apos;kid&apos;) 循环123&gt;&gt;&gt;sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:... sum = sum + x... print(sum) range()函数:整数序列,包前不包后,range(5) 表示(0,1,2,3,4) 要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。 dictPython 内置的词典,极快的查找速度,原因 dict通过索引查找 一个Key对应一个value,如果有多个,后面的话替换掉前面的 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 需要牢记的第一条就是dict的key必须是不可变对象。 set一组key的集合,不存储value,在set中没有重复的key,无序的无重复的集合 重复元素自动过滤, add(key)添加元素,remove(key)删除元素 函数定义函数时，需要确定函数名和参数个数； 如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果； 函数执行完毕也没有return语句时，自动return None。 函数可以同时返回多个值，但其实就是一个tuple。 Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 切片:1&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 前十个数,取法 1&gt;&gt;&gt; L:10 L[开始位置:结束位置:间隔数],包含开始,不包含结束,每隔 间隔数 取数值 从10开始,每隔5取一个数,到90(不包含90)结束. 1&gt;&gt;&gt; L[10:90:5] 1[10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85] 123456&gt;&gt;&gt; tiangan = &apos;甲乙丙丁戊己庚辛壬癸&apos;&gt;&gt;&gt; dizhi = &apos;子丑寅卯辰巳午未申酉戌亥&apos;&gt;&gt;&gt;&gt;&gt;&gt; jiazi = [tiangan[x % len(tiangan)] + dizhi[x % len(dizhi)] for x in range(60)]&gt;&gt;&gt;&gt;&gt;&gt; print(jiazi) 1[&apos;甲子&apos;, &apos;乙丑&apos;, &apos;丙寅&apos;, &apos;丁卯&apos;, &apos;戊辰&apos;, &apos;己巳&apos;, &apos;庚午&apos;, &apos;辛未&apos;, &apos;壬申&apos;, &apos;癸酉&apos;, &apos;甲戌&apos;, &apos;乙亥&apos;, &apos;丙子&apos;, &apos;丁丑&apos;, &apos;戊寅&apos;, &apos;己卯&apos;, &apos;庚辰&apos;, &apos;辛巳&apos;, &apos;壬午&apos;, &apos;癸未&apos;, &apos;甲申&apos;, &apos;乙酉&apos;, &apos;丙戌&apos;,&apos;丁亥&apos;, &apos;戊子&apos;, &apos;己丑&apos;, &apos;庚寅&apos;, &apos;辛卯&apos;, &apos;壬辰&apos;, &apos;癸巳&apos;, &apos;甲午&apos;, &apos;乙未&apos;, &apos;丙申&apos;, &apos;丁酉&apos;, &apos;戊戌&apos;, &apos;己亥&apos;, &apos;庚子&apos;, &apos;辛丑&apos;, &apos;壬寅&apos;, &apos;癸卯&apos;, &apos;甲辰&apos;, &apos;乙巳&apos;, &apos;丙午&apos;, &apos;丁未&apos;, &apos;戊申&apos;, &apos;己酉&apos;,&apos;庚戌&apos;, &apos;辛亥&apos;, &apos;壬子&apos;, &apos;癸丑&apos;, &apos;甲寅&apos;, &apos;乙卯&apos;, &apos;丙辰&apos;, &apos;丁巳&apos;, &apos;戊午&apos;, &apos;己未&apos;, &apos;庚申&apos;, &apos;辛酉&apos;, &apos;壬戌&apos;, &apos;癸亥&apos;] map()和reduce().重点 map()函数接收两个参数,一个函数,一个Iterable, map()把函数作用在序列的每个元素上 例如: 代码如下: 12345&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] reduce的用法: reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 比方说对一个序列求和，就可以用reduce实现： 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25 filter()过滤函数,和map()类似,接收两个函数,一个函数,一个序列,把传入的函数作用于每个元素,返回的是True 或 False,根据返回值判断是否保留元素. 例如，在一个list中，删掉偶数，只保留奇数，可以这么写： 1234&gt;&gt;&gt;def is_odd(n): ... return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果:[1, 5, 9, 15] 把一个序列中的空字符串删掉，可以这么写： 12345&gt;&gt;&gt;def not_empty(s):... return s and s.strip()&gt;&gt;&gt;list(filter(not_empty, [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, None, &apos;C&apos;, &apos; &apos;]))# 结果: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 装饰器详细解释:网址 偏函数functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2： 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&apos;1000000&apos;)64&gt;&gt;&gt; int2(&apos;1010101&apos;)85]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Win7-64位系统安装TensorFlow]]></title>
      <url>%2F2017%2F03%2F11%2FWin7-64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85TensorFlow%2F</url>
      <content type="text"><![CDATA[TensorFlowGitHub地址 TensorFlow支持Python2.7和3.3以上版本,本文使用Python3.5,下载并将它添加到路径当中(在安装提示最下面选项打钩即可). 阅读MD文档,找到Installation-&gt;DownLoad and Setup-&gt;Pip installation on Windows 文中提示说这个TensorFlow需要一个MSVCP140.DLL文件,你当前系统可能没有安装,应该安装 Visual C++ 2015 redistributable (x64 version).按照提示一路Next就好. 开始安装: 打开命令行提示符,win+R输入cmd,打开即可,需要安装TensorFlow的CPU和GPU CPU安装:pip install –upgrade https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.0-cp35-cp35m-win_amd64.whl 复制粘贴到命令提示符,稍等片刻,就会自动安装,安装过程中有很多类似进度条的格子,代表进度; GPU安装: pip install –upgrade https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.0-cp35-cp35m-win_amd64.whl 同样复制粘贴,同样稍等片刻,同样自动安装,同样有类似进度条格子 Cpu和GPU安装好之后,下面会有Test the TensorFlow installation来检测TensorFlow的安装情况,还会在安装一个CUDA:下载地址 安装cudnn 下载地址,将其拷贝到CUDA的安装目录下,里面3个文件夹分别有一个文件,将其按照目录拷贝到CUDA的各个对应的文件中。 将CUDA的路径添加到环境变量中… 检测是否安装成功: 在命令行中打开python 环境 12345678910111213&gt; python&gt;&gt; &gt;&gt;&gt; import tensorflow as tf&gt; &gt;&gt;&gt; hello = tf.constant(&apos;Hello, TensorFlow!&apos;)&gt; &gt;&gt;&gt; sess = tf.Session()&gt; &gt;&gt;&gt; sess.run(hello)&gt; Hello, TensorFlow!&gt; &gt;&gt;&gt; a = tf.constant(10)&gt; &gt;&gt;&gt; b = tf.constant(32)&gt; &gt;&gt;&gt; sess.run(a+b)&gt; 42&gt; &gt;&gt;&gt;&gt; 如果正确显示以上内容,就是成功了. 对抗网络学习指南,地址 安装 numpy +mkl,地址 找到numpy+mkl 下载文件的文件,shift+鼠标右键 点击在此处打开命令窗口,输入pip install+下载文件的全名.whl 安装Scipy.whl 地址 安装方法同上。 这个错误 是因为没有安装Pillow ,安装命令 pip3 install Pillow 1AttributeError: module &apos;scipy.misc&apos; has no attribute &apos;imread&apos; 可能出现的错误,基本上都能在这里找到,请耐心阅读英语, import tensorflow as tf I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cublas64_80.dll locally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cudnn64_5.dll lo cally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cufft64_80.dll l ocally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library nvcuda.dll local ly I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library curand64_80.dll locally hello = tf.constant(‘Hello,TensorFlow’) sess = tf.Session() E c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\cuda\cuda_driver.cc:509] failed call to cuInit: CUDA_ERROR_NO_DEVICE I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stream_executor\cuda\cuda_diagnostics.cc:158] retrieving CUDA diagnostic information for host: snow-PCI c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stream_executor\cuda\cuda_diagnostics.cc:165] hostname: snow-PC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新出发]]></title>
      <url>%2F2017%2F03%2F02%2FMy-New-Post%2F</url>
      <content type="text"><![CDATA[重新出发. 到目前为止,这个网站,我已经折腾3天了,从二月的最后一天,到现在,一直在忙活与创建这个个人博客… 不过感觉还不错,希望大于失望,又学习了一项新技能,内心还是禁不住泛开了花一样的开心。 是的,我喜欢新事物,喜欢学习,好奇心的确能成为促使你进步的动力,可难得的是—坚持. 对,坚持很重要,而且…是异常的难.能把一件事情坚持到底,真的十分令人敬佩. 我想说的是,无论你遇到任何困难事情,先静下心来,分析下事件的缘由,找到解决问题的突破口,一步步走起来,困难也就迎刃而解了.与此同时,吸取经验教训,争取能够在未雨绸缪. 满载信心,重新出发,永不放弃. Never Never Never Give Up.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[发现小偷]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%8F%91%E7%8E%B0%E5%B0%8F%E5%81%B7%2F</url>
      <content type="text"><![CDATA[2016年12月28号中午从新郑机场买了去郑州汽车站的巴士票。到了郑州汽车站买了两点十分回家的票,检票上车后,我看旁边有位带小孩子的年轻妈妈,就让她们俩先上车了。 ​就在这时,有一位戴着黑色口罩,左肩挎着皮包的中年男子紧跟着那位女士,一直在向上挤,我就隐隐感觉不对劲,我的眼睛在向下看,余光里模糊地看到那位男子将手伸到前面那位女士的口袋里并迅速回放到胸前,然后他就不再向上挤了,我看了他一眼,他往放行李的方向看去,然后向后退,退出排队上车的人群,我就在怀疑:他是小偷?!然后上车去了。 站在车门口将票给车上的检票人员检查,看了一眼车外,那个带着黑色口罩的男子还站在挡风玻璃前,我又盯着他看了几秒钟,对视~~ 继续朝着车后面走,然后我就想问问前面那位女士有没有丢掉什么东西。 前面有人挡着走廊了,后面有乘客上来,我就说了声:往前走一点吧。 等我把位置找到,行李放好,那位女士在走廊右侧,说了声:”我的手机被人掏走了!” 到此时,我才确定那个中年男子就是小偷! 我对那个女士说,我刚才看见下面有个人老在你后面挤,可能就是他,然后女士对我说:你怎么不告诉我?我说:当时我还不确定。 此时,最后排的一对情侣的男方说了:这个时候手机被掏走多正常啊!自己不小心点,怪谁啊?! 我觉得这句话没有同情的意思。 女士向检票人员告知无果后,借我电话向她家里说明情况,在她打电话的时候,前面一位大叔听到她向家里说手机被偷的事情,向后面看了看,我亲眼看到那位大叔一个鄙夷的眼神和一声轻微的冷笑。 我觉得这些动作并不是同情。 此时让我惊讶的是,车里都是在说这位女士真不小心,被掏走手机再正常不过了,而没人说了一句同情的话或者声讨小偷的话! 我不知道同情管不管用或者那位女士需不需要同情。 但,那是我是真的很同情她。 或许,我应该早点揭发那个小偷,可我只是发现了而已…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>%2F2017%2F02%2F28%2Farticle-tittle%2F</url>
      <content type="text"><![CDATA[时间:2017年2月28号,23:52分创建. 新的旅程刚刚开始,你要努力!]]></content>
    </entry>

    
  
  
</search>
