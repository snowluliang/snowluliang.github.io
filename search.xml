<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python学习(二)]]></title>
      <url>%2F2017%2F03%2F24%2FPython%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 1,模块, 模块最大的好处就是提高了代码的可维护性,避免函数名和包名的冲突, 2,使用和安装第三方模块 先import导入,第三方模块,就能用到数据此模块当中的函数和属性 下载地址 3,面向对象编程 Object Oriented Programming 简称OOP,是一种程序设计思想,OOP把对象作为程序的基本单元,一个对象包含函数和操作函数的方法; 4,类和实例 面向对象最重要的概念类(class)和实例(instance) 1234class Student(object): def init(self, name, score): self.name = name self.score = score init 前后有两个下划线,第一个参数始终是self, 5,访问限制 Class内部有属性和方法,外部可以直接用实例来操作类的属性和方法,隐藏了内部复杂的逻辑, 如果不想让内部属性被外部访问,可以把属性名称前面加上两个下划线__,这样内部属性就变成了私有变量,外部不可访问; 1234class Student(object): def init(self, name, score): self.name = name self.score = score 如果需要对属性变量进行更改或取值,可以给类添加get和set方法,通过,get_name,set_sorce,进行修改; 123456789class Student(object): ... def get_name(self): return self.__name def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError(&apos;bad score&apos;) 其次, XXX 类似这样前后带有双下划线的变量,不是私有变量,可以随意访问. _XXX 带有一个下划线的变量,视为私有变量,不要轻易访问; 带有双下划线的私有变量一定要从外部访问嘛? 不一定,带有双下划线的私有变量,Python解释器,其实把 name 变量给成了 Student _ name, 所以,还是可以通过, _Student__name 的形式进行访问; 但是,强烈建议不要这么做.因为不同版本的Python解释器可能会把 __name 改成不同的变量; 6,继承和多态 继承最大的好处就是,子类可以拥有父类的全部方法和功能 123class Animal(object): def run(self): print(&apos;Animal is running...&apos;) 123class Dog(Animal): def run(self): print(&apos;Dog is running...&apos;) 123class Cat(Animal): def run(self): print(&apos;Cat is running...&apos;) Animal就是Dog,Cat的父类,Dog,Cat就是Animal的子类,并拥有父类的全部方法 子类和父类中拥有相同run()方法,说明子类run()方法覆盖了父类run()的方法,代码运行时候就会调用 子类的run()方法,这就是继承的另一个好处:多态 当然也可以添加父类没有的方法 判断一个变量是否是某个类型可以用isinstance()判断： 12&gt;&gt;&gt; isinstance(c, Animal)True 继承关系树: 静态语言 vs 动态语言 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者 它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一 个run()方法就可以了： 7,获取对象信息 想要知道该对象是什么类型的 ①.type()方法 123456&gt;&gt;&gt; type(123)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; type(&apos;str&apos;)&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; type(None)&lt;type(None) &apos;NoneType&apos;&gt; type返回的是对应的Class类型. 比较两个变量的type类型是否相同: ②.instance()方法 先创建变量类型: 123&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky() 判断: 1234&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)True ③.dir()方法 想要或去一个对象的所有属性和方法,可以使用dir()方法,返回的是一个包含字符串的list,如: 1&gt;&gt;&gt; dir(&apos;ABC&apos;) 1[&apos;add&apos;, &apos;class&apos;, &apos;contains&apos;, &apos;delattr&apos;, &apos;dir&apos;, &apos;doc&apos;, &apos;eq&apos;, &apos;format&apos;, &apos;ge&apos;, &apos;getattribute&apos;, &apos;getitem&apos;, &apos;getnewargs&apos;, &apos;gt&apos;, &apos;hash&apos;, &apos;init&apos;, &apos;iter&apos;, &apos;le&apos;, &apos;len&apos;, &apos;lt&apos;, &apos;mod&apos;, &apos;mul&apos;, &apos;ne&apos;, &apos;new&apos;, &apos;reduce&apos;, &apos;reduce_ex&apos;, &apos;repr&apos;, &apos;rmod&apos;, &apos;rmul&apos;, &apos;setattr&apos;, &apos;sizeof&apos;, &apos;str&apos;, &apos;subclasshook&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;] 还可以配合,getattr(),setattr()和hasattr()方法来操作属性和方法,如: 123456&gt;&gt;&gt; class MyObject(object):... def init(self):... self.x = 9... def power(self):... return self.x * self.x...&gt;&gt;&gt; obj = MyObject() 然后,测试是否含有属性: 12345678910111213&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？False&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？True&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;19&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;19 如果试图获取不存在的属性,会报错:AttributeError的错误 8,实例属性和类属性 在编写实例属性和类属性的话,尽量不要使用相同的名字,相同名称的实例属性会覆盖掉类属性,如果 删除掉实例属性的话,再用相同名称,访问到的是类属性.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(一)]]></title>
      <url>%2F2017%2F03%2F12%2FPython%E5%AD%A6%E4%B9%A0-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 1,list: Pytho内置的数据类型列表,list是一种可变有序集合,可以随时添加和删除其中的元素.可添加元素到末尾. 123&gt;&gt;&gt; classmates.append(&apos;Adam&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 也可以指定索引号,添加到指定位置, 123&gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 删除元素: pop()方法 删除末尾元素,也可指定索引删除指定位置pop(i) 2,tuple 另外一种有序列表,元组,和list非常相似,但tuple一旦初始化,就不能更改, 代码更安全,能用tuple替代list,就替换掉, 定义一个元素时,例子: 12&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 3,条件判断 1234567&gt;&gt;&gt;age = 20&gt;&gt;&gt;if age &gt;= 6: ... print(&apos;teenager&apos;)...elif age &gt;= 18: ... print(&apos;adult&apos;)...else: ... print(&apos;kid&apos;) 4,循环 123&gt;&gt;&gt;sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:... sum = sum + x... print(sum) range()函数:整数序列,包前不包后,range(5) 表示(0,1,2,3,4) 要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。 5,dict Python 内置的词典,极快的查找速度,原因 dict通过索引查找 一个Key对应一个value,如果有多个,后面的话替换掉前面的 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 需要牢记的第一条就是dict的key必须是不可变对象。 6,set 一组key的集合,不存储value,在set中没有重复的key,无序的无重复的集合 重复元素自动过滤, add(key)添加元素,remove(key)删除元素 7,函数 定义函数时，需要确定函数名和参数个数； 如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果； 函数执行完毕也没有return语句时，自动return None。 函数可以同时返回多个值，但其实就是一个tuple。 Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 8,切片: 1&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 前十个数,取法 1&gt;&gt;&gt; L:10 L[开始位置:结束位置:间隔数],包含开始,不包含结束,每隔 间隔数 取数值 从10开始,每隔5取一个数,到90(不包含90)结束. 1&gt;&gt;&gt; L[10:90:5] 1[10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85] 123456&gt;&gt;&gt; tiangan = &apos;甲乙丙丁戊己庚辛壬癸&apos;&gt;&gt;&gt; dizhi = &apos;子丑寅卯辰巳午未申酉戌亥&apos;&gt;&gt;&gt;&gt;&gt;&gt; jiazi = [tiangan[x % len(tiangan)] + dizhi[x % len(dizhi)] for x in range(60)]&gt;&gt;&gt;&gt;&gt;&gt; print(jiazi) 1[&apos;甲子&apos;, &apos;乙丑&apos;, &apos;丙寅&apos;, &apos;丁卯&apos;, &apos;戊辰&apos;, &apos;己巳&apos;, &apos;庚午&apos;, &apos;辛未&apos;, &apos;壬申&apos;, &apos;癸酉&apos;, &apos;甲戌&apos;, &apos;乙亥&apos;, &apos;丙子&apos;, &apos;丁丑&apos;, &apos;戊寅&apos;, &apos;己卯&apos;, &apos;庚辰&apos;, &apos;辛巳&apos;, &apos;壬午&apos;, &apos;癸未&apos;, &apos;甲申&apos;, &apos;乙酉&apos;, &apos;丙戌&apos;,&apos;丁亥&apos;, &apos;戊子&apos;, &apos;己丑&apos;, &apos;庚寅&apos;, &apos;辛卯&apos;, &apos;壬辰&apos;, &apos;癸巳&apos;, &apos;甲午&apos;, &apos;乙未&apos;, &apos;丙申&apos;, &apos;丁酉&apos;, &apos;戊戌&apos;, &apos;己亥&apos;, &apos;庚子&apos;, &apos;辛丑&apos;, &apos;壬寅&apos;, &apos;癸卯&apos;, &apos;甲辰&apos;, &apos;乙巳&apos;, &apos;丙午&apos;, &apos;丁未&apos;, &apos;戊申&apos;, &apos;己酉&apos;,&apos;庚戌&apos;, &apos;辛亥&apos;, &apos;壬子&apos;, &apos;癸丑&apos;, &apos;甲寅&apos;, &apos;乙卯&apos;, &apos;丙辰&apos;, &apos;丁巳&apos;, &apos;戊午&apos;, &apos;己未&apos;, &apos;庚申&apos;, &apos;辛酉&apos;, &apos;壬戌&apos;, &apos;癸亥&apos;] 9,map()和reduce().重点 map()函数接收两个参数,一个函数,一个Iterable, map()把函数作用在序列的每个元素上 例如: 代码如下: 12345&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] reduce的用法: reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 比方说对一个序列求和，就可以用reduce实现： 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25 10,filter() 过滤函数,和map()类似,接收两个函数,一个函数,一个序列,把传入的函数作用于每个元素,返回的是True 或 False,根据返回值判断是否保留元素. 例如，在一个list中，删掉偶数，只保留奇数，可以这么写： 1234&gt;&gt;&gt;def is_odd(n): ... return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果:[1, 5, 9, 15] 把一个序列中的空字符串删掉，可以这么写： 12345&gt;&gt;&gt;def not_empty(s):... return s and s.strip()&gt;&gt;&gt;list(filter(not_empty, [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, None, &apos;C&apos;, &apos; &apos;]))# 结果: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 11,装饰器 详细解释:网址 12,偏函数 functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2： 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&apos;1000000&apos;)64&gt;&gt;&gt; int2(&apos;1010101&apos;)85 …]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Win7-64位系统安装TensorFlow]]></title>
      <url>%2F2017%2F03%2F11%2FWin7-64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85TensorFlow%2F</url>
      <content type="text"><![CDATA[TensorFlowGitHub地址 TensorFlow支持Python2.7和3.3以上版本,本文使用Python3.5,下载并将它添加到路径当中(在安装提示最下面选项打钩即可). 阅读MD文档,找到Installation-&gt;DownLoad and Setup-&gt;Pip installation on Windows 文中提示说这个TensorFlow需要一个MSVCP140.DLL文件,你当前系统可能没有安装,应该安装 Visual C++ 2015 redistributable (x64 version).按照提示一路Next就好. 开始安装: 打开命令行提示符,win+R输入cmd,打开即可,需要安装TensorFlow的CPU和GPU CPU安装:pip install –upgrade https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.0-cp35-cp35m-win_amd64.whl 复制粘贴到命令提示符,稍等片刻,就会自动安装,安装过程中有很多类似进度条的格子,代表进度; GPU安装: pip install –upgrade https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.0-cp35-cp35m-win_amd64.whl 同样复制粘贴,同样稍等片刻,同样自动安装,同样有类似进度条格子 Cpu和GPU安装好之后,下面会有Test the TensorFlow installation来检测TensorFlow的安装情况,还会在安装一个CUDA:下载地址 安装cudnn 下载地址,将其拷贝到CUDA的安装目录下,里面3个文件夹分别有一个文件,将其按照目录拷贝到CUDA的各个对应的文件中。 将CUDA的路径添加到环境变量中… 检测是否安装成功: 在命令行中打开python 环境 12345678910111213&gt; python&gt;&gt; &gt;&gt;&gt; import tensorflow as tf&gt; &gt;&gt;&gt; hello = tf.constant(&apos;Hello, TensorFlow!&apos;)&gt; &gt;&gt;&gt; sess = tf.Session()&gt; &gt;&gt;&gt; sess.run(hello)&gt; Hello, TensorFlow!&gt; &gt;&gt;&gt; a = tf.constant(10)&gt; &gt;&gt;&gt; b = tf.constant(32)&gt; &gt;&gt;&gt; sess.run(a+b)&gt; 42&gt; &gt;&gt;&gt;&gt; 如果正确显示以上内容,就是成功了. 对抗网络学习指南,地址 安装 numpy +mkl,地址 找到numpy+mkl 下载文件的文件,shift+鼠标右键 点击在此处打开命令窗口,输入pip install+下载文件的全名.whl 安装Scipy.whl 地址 安装方法同上。 这个错误 是因为没有安装Pillow ,安装命令 pip3 install Pillow 1AttributeError: module &apos;scipy.misc&apos; has no attribute &apos;imread&apos; 可能出现的错误,基本上都能在这里找到,请耐心阅读英语, import tensorflow as tf I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cublas64_80.dll locally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cudnn64_5.dll lo cally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cufft64_80.dll l ocally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library nvcuda.dll local ly I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library curand64_80.dll locally hello = tf.constant(‘Hello,TensorFlow’) sess = tf.Session() E c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\cuda\cuda_driver.cc:509] failed call to cuInit: CUDA_ERROR_NO_DEVICE I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stream_executor\cuda\cuda_diagnostics.cc:158] retrieving CUDA diagnostic information for host: snow-PCI c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stream_executor\cuda\cuda_diagnostics.cc:165] hostname: snow-PC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新出发]]></title>
      <url>%2F2017%2F03%2F02%2FMy-New-Post%2F</url>
      <content type="text"><![CDATA[重新出发. 到目前为止,这个网站,我已经折腾3天了,从二月的最后一天,到现在,一直在忙活与创建这个个人博客… 不过感觉还不错,希望大于失望,又学习了一项新技能,内心还是禁不住泛开了花一样的开心。 是的,我喜欢新事物,喜欢学习,好奇心的确能成为促使你进步的动力,可难得的是—坚持. 对,坚持很重要,而且…是异常的难.能把一件事情坚持到底,真的十分令人敬佩. 我想说的是,无论你遇到任何困难事情,先静下心来,分析下事件的缘由,找到解决问题的突破口,一步步走起来,困难也就迎刃而解了.与此同时,吸取经验教训,争取能够在未雨绸缪. 满载信心,重新出发,永不放弃. Never Never Never Give Up.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[发现小偷]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%8F%91%E7%8E%B0%E5%B0%8F%E5%81%B7%2F</url>
      <content type="text"><![CDATA[2016年12月28号中午从新郑机场买了去郑州汽车站的巴士票。到了郑州汽车站买了两点十分回家的票,检票上车后,我看旁边有位带小孩子的年轻妈妈,就让她们俩先上车了。 ​就在这时,有一位戴着黑色口罩,左肩挎着皮包的中年男子紧跟着那位女士,一直在向上挤,我就隐隐感觉不对劲,我的眼睛在向下看,余光里模糊地看到那位男子将手伸到前面那位女士的口袋里并迅速回放到胸前,然后他就不再向上挤了,我看了他一眼,他往放行李的方向看去,然后向后退,退出排队上车的人群,我就在怀疑:他是小偷?!然后上车去了。 站在车门口将票给车上的检票人员检查,看了一眼车外,那个带着黑色口罩的男子还站在挡风玻璃前,我又盯着他看了几秒钟,对视~~ 继续朝着车后面走,然后我就想问问前面那位女士有没有丢掉什么东西。 前面有人挡着走廊了,后面有乘客上来,我就说了声:往前走一点吧。 等我把位置找到,行李放好,那位女士在走廊右侧,说了声:”我的手机被人掏走了!” 到此时,我才确定那个中年男子就是小偷! 我对那个女士说,我刚才看见下面有个人老在你后面挤,可能就是他,然后女士对我说:你怎么不告诉我?我说:当时我还不确定。 此时,最后排的一对情侣的男方说了:这个时候手机被掏走多正常啊!自己不小心点,怪谁啊?! 我觉得这句话没有同情的意思。 女士向检票人员告知无果后,借我电话向她家里说明情况,在她打电话的时候,前面一位大叔听到她向家里说手机被偷的事情,向后面看了看,我亲眼看到那位大叔一个鄙夷的眼神和一声轻微的冷笑。 我觉得这些动作并不是同情。 此时让我惊讶的是,车里都是在说这位女士真不小心,被掏走手机再正常不过了,而没人说了一句同情的话或者声讨小偷的话! 我不知道同情管不管用或者那位女士需不需要同情。 但,那是我是真的很同情她。 或许,我应该早点揭发那个小偷,可我只是发现了而已…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>%2F2017%2F02%2F28%2Farticle-tittle%2F</url>
      <content type="text"><![CDATA[时间:2017年2月28号,23:52分创建. 新的旅程刚刚开始,你要努力!]]></content>
    </entry>

    
  
  
</search>
