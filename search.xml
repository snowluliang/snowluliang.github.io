<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python学习(四)]]></title>
      <url>%2F2017%2F03%2F27%2FPython%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 IO编程1,文件读写取 在磁盘上读写文件的功能都是由操作系统提供的,现代操作系统不允许一般的程序直接操作磁盘,读写文件就是请求操作系统打开一个文件对象,然后通过操作系统提供的接口从这个文件对象中读取数据(读文件),或者把数据写入文件对象(写文件). 使用Python内置的open()函数,传入文件路径名和标示符,就能打开一个文件,如果文件不存在,会抛出一个IOError,并指出错误出现的地方: 1234&gt;&gt;&gt; f=open(&apos;/Users/michael/notfound.txt&apos;, &apos;r&apos;)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;FileNotFoundError:[Errno 2] No such file or directory: &apos;/Users/michael/notfound.txt&apos; r,表示读取,如果打开成功,read()方法可以读取文件的全部内容,把内容读到内存,用str对象表示,最后要调用close()方法来关闭读取操作,这一步必须有,很重要. 在文件读写的过程中,都有可能发生IOError,后面的close()方法就不会执行了,Python内置的有with语句自动帮我们自动调用close()方法: 12with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f: print(f.read()) read()方法可以读取目标文件的全部内容,这不太保险,如果文件过大,内存容量不够,就挂掉了,如果文件很小的话,这个很方便. read(size)方法可以每次读取多少字节,在不确定文件大小的情况下,反复调用read(size)方法最保险. readline()可以读取一行. readlines()可以读取所有行的内容并按行返回list. 如果是配置文件,这个很方便. 按照需求,选取合适的方法. 二进制文件的读取,如图片,视频,用’rb‘模式打开: 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)&gt;&gt;&gt; f.read()b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节 想要读取特定编码的文件对象,需要在open()函数中传入编码类型encoding: 123&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)&gt;&gt;&gt; f.read()&apos;测试&apos; 如遇到编码不规范的文件,可能会有UnicodeDecodeError. 文件中可能含有非法字符,在open()函数中黑可以传入一个errors参数,表示如果遇到异常如何处理, 1&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;, errors=&apos;ignore&apos;) 2,文件写入 文件写入和文件读取类似,只不过在open()函数中的参数是’w’和’wb’,用来读取文本文件和二进制文件 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)&gt;&gt;&gt; f.close() 用with语句最保险: 12with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f: f.write(&apos;Hello, world!&apos;) 反复调用write()方法,最重要的是还要调用close()方法,这样才能保证,系统把数据全部写入到指定文件中,如果要指定编码类型,只需要在open()函数中传入指定的的编码就可以了. 3,StringIO,是在内存中读写str: 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write(&apos;hello&apos;)5 #字符个数&gt;&gt;&gt; f.write(&apos; &apos;)1&gt;&gt;&gt; f.write(&apos;world!&apos;)6&gt;&gt;&gt; print(f.getvalue())hello world! getvalue()是用于获取写入后的字符串. 读取StringIO和读取文件类似 1234567891011&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;)&gt;&gt;&gt; while True:... s = f.readline()... if s == &apos;&apos;:... break... print(s.strip())...Hello!Hi!Goodbye! 4,BytesIO,用于读写二进制数据. 12345&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))6&gt;&gt;&gt; print(f.getvalue())b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 用BytesIO写入的不是str,而是经过编码后的byte字节,读取类似StringIO,先获得BytesIO的对象,进行读取: 1234&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)&gt;&gt;&gt; f.read()b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 5,操作文件和目录 在Python中操作文件和目录的命令都在os模块和os.path模块当中 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.name &apos;nt&apos; 操作系统类型,nt 代表Windows,还有POSIX类型,代表Linux,Unix,或者MacOs. 环境变量: 1&gt;&gt;&gt; os.environ 取得某个环境变量的值: 1&gt;&gt;&gt; os.environ.get(&apos;path&apos;) 当前目录的绝对路径: 1&gt;&gt;&gt; os.path.abspath(&apos;.&apos;) 把两个路径合成一个时: 1os.path.join() 拆分路径: 12&gt;&gt;&gt; os.path.split(&apos;C:/Users/snow/Desktop/22.txt&apos;)(&apos;C:/Users/snow/Desktop&apos;, &apos;22.txt&apos;) 拆分直接得到文件扩展名: 12&gt;&gt;&gt; os.path.splitext(&apos;C:/Users/snow/Desktop/22.txt&apos;)(&apos;C:/Users/snow/Desktop/22&apos;, &apos;.txt&apos;) 合并,拆分路径操作,并不要次文件真实存在,只是对字符串进行操作. 对文件重命名: 1&gt;&gt;&gt;os.rename(&apos;test.txt&apos;, &apos;test.py&apos;) 删掉文件: 1&gt;&gt;&gt;os.remove(&apos;test.py&apos;) shutil模块中有copyfile()函数. 列出当前目录下的所有文件夹: 12&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)][&apos;DLLs&apos;, &apos;Doc&apos;, &apos;include&apos;, &apos;Lib&apos;, &apos;libs&apos;, &apos;Scripts&apos;, &apos;tcl&apos;, &apos;Tools&apos;] 列出所有的.py文件: 123&gt;&gt;&gt; import os&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;][&apos;break.py&apos;, &apos;if.py&apos;, &apos;learning.py&apos;, &apos;secret.py&apos;, &apos;sum.py&apos;, &apos;turtle.py&apos;] 6,序列化 把变量从内存中变成可存储或传输的过程称之为序列化,在Python中叫pickling,序列化之后,就可以把序列化后的内容写入磁盘,或者通过网络传输到别的机器上. 反过来,把序列化之后的对象读到内存中,称为反序列化,unpickling. pickle模块实现序列化: 1234&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&apos;Snow&apos;,age=20,score=88)&gt;&gt;&gt; pickle.dumps(d)b&apos;\x80\x03&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x04\x00\x00\x00Snowq\x02X\x05\x00\x00\x00scoreq\x03KXX\x03\x00\x00\x00ageq\x04K\x14u.&apos; pickle.dumps()方法可以把任意对象序列化成一个bytes,然后,就可以把bytes写入文件,或者,用pickle.dump()直接把对象序列化后写入一个file-like-Object: 123456&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&apos;snow&apos;,age =22,sorce=90)&gt;&gt;&gt; f = open(&apos;33.txt&apos;,&apos;wb&apos;)&gt;&gt;&gt; pickle.dump(d,f)&gt;&gt;&gt; f.close&lt;built-in method close of _io.BufferedWriter object at 0x00000000011AA938&gt; 33.txt中的内容像这样: 12345678003 7d71 0028 5803 0000 0061 6765 71014b16 5805 0000 0073 6f72 6365 7102 4b5a5804 0000 006e 616d 6571 0358 0400 0000736e 6f77 7104 752e 8003 7d71 0028 58030000 0061 6765 7101 4b16 5805 0000 00736f72 6365 7102 4b5a 5804 0000 006e 616d6571 0358 0400 0000 736e 6f77 7104 752e 当把对象从磁盘中读到内存时候,可以先读取一个bytes,然后用pickle.loads()方法反序列化出对象,也可以用pickl.load()方法从一个file-like-Object中直接反序列化出对象, 12345&gt;&gt;&gt; f = open(&apos;33.txt&apos;,&apos;rb&apos;)&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;&apos;age&apos;: 22, &apos;sorce&apos;: 90, &apos;name&apos;: &apos;snow&apos;&#125; pickle只能用于python,不同版本的互不兼容,只能用pickle存储一些不太重要的信息. JSON 要在不同编程语言之间传递对象,就要把对象序列化为标准格式,JSON表示的是一个字符串,可以被所有语言读取,可以方便的存储到磁盘或者通过网络传输,可以直接在Web页面读取. JSON类型 Python类型 {} dict [] list “string” str 1234.56 int或float true/false True/False null None python对象转化为JSON: 1234&gt;&gt;&gt; import json&gt;&gt;&gt; d = dict(name=&apos;snow&apos;,age =22,sorce=90)&gt;&gt;&gt; json.dumps(d)&apos;&#123;&quot;age&quot;: 22, &quot;sorce&quot;: 90, &quot;name&quot;: &quot;snow&quot;&#125;&apos; 使用JSON反序列化为Python对象,用loads(),或者load()方法,loads()方法将JSON的字符串反序列化,load()方法将从file-like-Object读取字符串并反序列化: 1234&gt;&gt;&gt; import json&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 22, &quot;sorce&quot;: 90, &quot;name&quot;: &quot;snow&quot;&#125;&apos;&gt;&gt;&gt; json.loads(json_str)&#123;&apos;name&apos;: &apos;snow&apos;, &apos;age&apos;: 22, &apos;sorce&apos;: 90&#125; JSON标准规定JSON编码是UTF-8. Python语言序列化的模块是pickle,想要把序列化更通用,更符合web标准,就可以用JSON.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(三)]]></title>
      <url>%2F2017%2F03%2F25%2FPython%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 1,面型对象高级编程 数据封装,继承和多态只是面向对象编程的3个基础概念 2, __slots__ 定义一个Class后,创建一个class实例后,可以给实例绑定任何属性和方法,动态语言的灵活性, 12class Student(object): pass 创建实例,绑定一个属性值: 123&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = &apos;Michael&apos; # 动态给实例绑定一个属性&gt;&gt;&gt; print(s.name)Michael 还可以为其绑定一个方法, 但是,这个方法只对当前实例有效,对其他实例没有效果。 使用 __slots__ 可以为类限定以后添加的属性, 12class Student(object): slots = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称 这样,除了name和age属性之外的属性,都不可以添加了,会报错 1234567&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos; 使用 __slots__ 仅对当前实例有效,对其子类则没有效果,除非在子类中定义 __slots__ 方法 3,@property @property就是可以让实例的方法当做属性来用,例如:给Screen对象加上width和height属性,以及一个只读属性的resolution, 1234567891011121314151617181920class Screen(object): @property #设置getter方法 def width(self): return self._width @width.setter #设置setter方法 def width(self,value): self._width = value @property #设置getter方法 def height(self): return self._height @height.setter #设置setter方法 def height(self,value): self._height = value @property #没有setter方法,只读属性,通过计算出来的 def resolution(self): return self.width*self.height 测试结果: 12345s = Screen()s.width = 1024 #这里就相当于s.set_widths.height = 768 #这里就相当于s.set_heightprint(s.resolution) 786432 4,多重继承 Python允许使用多重继承,例如:狗是一种会跑的,食肉的,哺乳型动物,就可以继承自定义的 会跑的动物(Runnable),食肉的(Carnivorous),哺乳型(Mammal),动物(Animal)… 12class Dog(Mammal,Animal,Carnivorous): pass 这种模式叫做MixIn,目的是为了给一个类增加多个功能,在设计类的时候,优先考虑通过多重继承来组合多个MixIn的功能,而不是设计复杂层次的继承关系, 5,Enum枚举类 12345678910from enum import Enum, unique@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 @unique用来检查有没有重复值 访问枚举类型 12345678&gt;&gt;&gt; print(Weekday.Tue)Weekday.Tue&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])Weekday.Tue&gt;&gt;&gt; print(Weekday.Tue.value)2&gt;&gt;&gt; print(Weekday(1))Weekday.Mon 可以根据枚举名称引用常量,也可以用value的值获取枚举常量 6,元类(metalclass) 动态语言在函数和类的定义过程中,不是编译时定义的 ,而是运行时动态创建的, 当我们需要创建一个实例时,首先要先定义一个类,然后在创建类的实例,所以顺序就是 –&gt;创建类–&gt;创建实例, 但是创建类的时候呢?这是就是先创建metalclass,在创建类,在创建实例,顺序就是–&gt;创建metalclass–&gt;创建类–&gt;创建类的实例 可以理解为,类就是metalclass的实例, ①它可以拦截类的创建, ②对类进行修改 ③返回修改后的类 详细解释 7,错误,调试,测试 ①,错误处理 try…except…finally…错误处理机制 123456789try: print(&apos;try...&apos;) r = 10 / 0 print(&apos;result:&apos;, r)except ZeroDivisionError as e: print(&apos;except:&apos;, e)finally: print(&apos;finally...&apos;)print(&apos;END&apos;) 当try执行代码块出错时候,后续代码将不执行,而是执行except语句中的代码,提示错误的出现,如果finally语句中有代码,再执行其语句中的代码, 1234try...result: 5finally...END 也可以添加多个except语句块,捕获不同错误,还可以加入else语句块, 123456except ValueError as e: print(&apos;ValueError:&apos;, e)except ZeroDivisionError as e: print(&apos;ZeroDivisionError:&apos;, e)else: print(&apos;no error!&apos;) 错误类型和继承关系 try…except..还可以跨越多层级调用,可以减少try..except..代码块的书写 1234567891011def foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar(&apos;0&apos;) except Exception as e: print(&apos;Error:&apos;, e) finally: print(&apos;finally...&apos;) 如果错误没有被捕获,会一直向上抛,直到Python解释器捕获,打印错误信息,程序退出, 出现错误不可怕,不知道错误出现在哪里才可怕,要找到错误出现的地方,出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。 通过logging可以方便的记录错误, 12except Exception as e: logging.exception(e) 抛出错误raise 12345def foo(s): n = int(s) if n==0: raise FooError(&apos;invalid value: %s&apos; % s) return 10 / n 只有在必要的时候才使用自定义的错误类,如果可以用Python内置的错误类,尽量使用内置的错误类, ②调试 程序调试的方法有: print()直接打印处错误,还需要手动删除 断言assert, 123456def foo(s): n = int(s) assert n != 0, &apos;n is zero!&apos; return 10 / ndef main(): foo(&apos;0&apos;) 表达式 n!=0应该是true,否则,后面的代码会出错,如果断言失败,会抛出AssertionError, 启用Python解释器时候,可以启用-0来关闭断言 1$ python3 -0 err.py logging,它不会抛出错误,可以输出到文件,可以指定记录信息的级别,debug,info,warning,error等, pdb,python自带的调试器, 1234# err.pys = &apos;0&apos;n = int(s)print(10 / n) 启动调试器: 123$ python3 -m pdb err.py&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()-&gt; s = &apos;0&apos; 输入命令n可以单步执行代码, 123456(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()-&gt; n = int(s)(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()-&gt; print(10 / n) 输入 p 变量名 可以查看变量 1234(Pdb) p s&apos;0&apos;(Pdb) p n0 输入q 退出调试 pdb.set_trace(),这个方法也是pdb调试的,但不需要单步执行, 123456# err.pyimport pdbs = &apos;0&apos;n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n) 只需要在可能出现错误的地方,加上pdb.set_trace(),代码执行到此时,会自动进入pdb调试模式,可以用p查看变量,用c继续执行 12345678910$ python3 err.py &gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()-&gt; print(10 / n)(Pdb) p n0(Pdb) cTraceback (most recent call last):File &quot;err.py&quot;, line 7, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero IDE调试,比较好的Python IDE 有PyCharm ③单元测试, 单元测试时对一个类,一个函数或者一个模块正确性检测的测试工作,就是确保一个程序模块的行为符合我们设计的测试用例,在将来进行修改时候,极大可能保证此模块仍然是正确的 ④文档测试 Python内置的 文档测试(doctest) 可以抽取文档中的代码直接运行 doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确 12345678910111213141516171819def fact(n): &apos;&apos;&apos;&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(2)2&gt;&gt;&gt; fact(-1)Traceback (most recent call last):ValueError &apos;&apos;&apos; if n &lt; 1: raise ValueError() if n == 1: return 1 return n * fact(n - 1)if__name__ == &apos;__main__&apos;: import doctest doctest.testmod()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(二)]]></title>
      <url>%2F2017%2F03%2F24%2FPython%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 1,模块, 模块最大的好处就是提高了代码的可维护性,避免函数名和包名的冲突, 2,使用和安装第三方模块 先import导入,第三方模块,就能用到数据此模块当中的函数和属性 下载地址 3,面向对象编程 Object Oriented Programming 简称OOP,是一种程序设计思想,OOP把对象作为程序的基本单元,一个对象包含函数和操作函数的方法; 4,类和实例 面向对象最重要的概念类(class)和实例(instance) 1234class Student(object): def init(self, name, score): self.name = name self.score = score init 前后有两个下划线,第一个参数始终是self, 5,访问限制 Class内部有属性和方法,外部可以直接用实例来操作类的属性和方法,隐藏了内部复杂的逻辑, 如果不想让内部属性被外部访问,可以把属性名称前面加上两个下划线__,这样内部属性就变成了私有变量,外部不可访问; 1234class Student(object): def init(self, name, score): self.name = name self.score = score 如果需要对属性变量进行更改或取值,可以给类添加get和set方法,通过,get_name,set_sorce,进行修改; 123456789class Student(object): ... def get_name(self): return self.__name def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError(&apos;bad score&apos;) 其次, __XXX__ 类似这样前后带有双下划线的变量,不是私有变量,可以随意访问. _XXX 带有一个下划线的变量,视为私有变量,不要轻易访问; 带有双下划线的私有变量一定要从外部访问嘛? 不一定,带有双下划线的私有变量,Python解释器,其实把, __name 变量给成了_Student__name, 所以,还是可以通过,_Student__name 的形式进行访问; 但是,强烈建议不要这么做.因为不同版本的Python解释器可能会把 __name 改成不同的变量; 6,继承和多态 继承最大的好处就是,子类可以拥有父类的全部方法和功能 123class Animal(object): def run(self): print(&apos;Animal is running...&apos;) 123class Dog(Animal): def run(self): print(&apos;Dog is running...&apos;) 123class Cat(Animal): def run(self): print(&apos;Cat is running...&apos;) Animal就是Dog,Cat的父类,Dog,Cat就是Animal的子类,并拥有父类的全部方法 子类和父类中拥有相同run()方法,说明子类run()方法覆盖了父类run()的方法,代码运行时候就会调用 子类的run()方法,这就是继承的另一个好处:多态 当然也可以添加父类没有的方法 判断一个变量是否是某个类型可以用isinstance()判断： 12&gt;&gt;&gt; isinstance(c, Animal)True 继承关系树: 静态语言 vs 动态语言 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者 它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一 个run()方法就可以了： 7,获取对象信息 想要知道该对象是什么类型的 ①.type()方法 123456&gt;&gt;&gt; type(123)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; type(&apos;str&apos;)&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; type(None)&lt;type(None) &apos;NoneType&apos;&gt; type返回的是对应的Class类型. 比较两个变量的type类型是否相同: ②.instance()方法 先创建变量类型: 123&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky() 判断: 1234&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)True ③.dir()方法 想要或去一个对象的所有属性和方法,可以使用dir()方法,返回的是一个包含字符串的list,如: 1&gt;&gt;&gt; dir(&apos;ABC&apos;) 1[&apos;add&apos;, &apos;class&apos;, &apos;contains&apos;, &apos;delattr&apos;, &apos;dir&apos;, &apos;doc&apos;, &apos;eq&apos;, &apos;format&apos;, &apos;ge&apos;, &apos;getattribute&apos;, &apos;getitem&apos;, &apos;getnewargs&apos;, &apos;gt&apos;, &apos;hash&apos;, &apos;init&apos;, &apos;iter&apos;, &apos;le&apos;, &apos;len&apos;, &apos;lt&apos;, &apos;mod&apos;, &apos;mul&apos;, &apos;ne&apos;, &apos;new&apos;, &apos;reduce&apos;, &apos;reduce_ex&apos;, &apos;repr&apos;, &apos;rmod&apos;, &apos;rmul&apos;, &apos;setattr&apos;, &apos;sizeof&apos;, &apos;str&apos;, &apos;subclasshook&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;] 还可以配合,getattr(),setattr()和hasattr()方法来操作属性和方法,如: 123456&gt;&gt;&gt; class MyObject(object):... def init(self):... self.x = 9... def power(self):... return self.x * self.x...&gt;&gt;&gt; obj = MyObject() 然后,测试是否含有属性: 12345678910111213&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？False&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？True&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;19&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;19 如果试图获取不存在的属性,会报错:AttributeError的错误 8,实例属性和类属性 在编写实例属性和类属性的话,尽量不要使用相同的名字,相同名称的实例属性会覆盖掉类属性,如果 删除掉实例属性的话,再用相同名称,访问到的是类属性.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(一)]]></title>
      <url>%2F2017%2F03%2F12%2FPython%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 1,list: Pytho内置的数据类型列表,list是一种可变有序集合,可以随时添加和删除其中的元素.可添加元素到末尾. 123&gt;&gt;&gt; classmates.append(&apos;Adam&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 也可以指定索引号,添加到指定位置, 123&gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 删除元素: pop()方法 删除末尾元素,也可指定索引删除指定位置pop(i) 2,tuple 另外一种有序列表,元组,和list非常相似,但tuple一旦初始化,就不能更改, 代码更安全,能用tuple替代list,就替换掉, 定义一个元素时,例子: 12&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 3,条件判断 1234567&gt;&gt;&gt;age = 20&gt;&gt;&gt;if age &gt;= 6: ... print(&apos;teenager&apos;)...elif age &gt;= 18: ... print(&apos;adult&apos;)...else: ... print(&apos;kid&apos;) 4,循环 123&gt;&gt;&gt;sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:... sum = sum + x... print(sum) range()函数:整数序列,包前不包后,range(5) 表示(0,1,2,3,4) 要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。 5,dict Python 内置的词典,极快的查找速度,原因 dict通过索引查找 一个Key对应一个value,如果有多个,后面的话替换掉前面的 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 需要牢记的第一条就是dict的key必须是不可变对象。 6,set 一组key的集合,不存储value,在set中没有重复的key,无序的无重复的集合 重复元素自动过滤, add(key)添加元素,remove(key)删除元素 7,函数 定义函数时，需要确定函数名和参数个数； 如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果； 函数执行完毕也没有return语句时，自动return None。 函数可以同时返回多个值，但其实就是一个tuple。 Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 8,切片: 1&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 前十个数,取法 1&gt;&gt;&gt; L:10 L[开始位置:结束位置:间隔数],包含开始,不包含结束,每隔 间隔数 取数值 从10开始,每隔5取一个数,到90(不包含90)结束. 1&gt;&gt;&gt; L[10:90:5] 1[10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85] 123456&gt;&gt;&gt; tiangan = &apos;甲乙丙丁戊己庚辛壬癸&apos;&gt;&gt;&gt; dizhi = &apos;子丑寅卯辰巳午未申酉戌亥&apos;&gt;&gt;&gt;&gt;&gt;&gt; jiazi = [tiangan[x % len(tiangan)] + dizhi[x % len(dizhi)] for x in range(60)]&gt;&gt;&gt;&gt;&gt;&gt; print(jiazi) 1[&apos;甲子&apos;, &apos;乙丑&apos;, &apos;丙寅&apos;, &apos;丁卯&apos;, &apos;戊辰&apos;, &apos;己巳&apos;, &apos;庚午&apos;, &apos;辛未&apos;, &apos;壬申&apos;, &apos;癸酉&apos;, &apos;甲戌&apos;, &apos;乙亥&apos;, &apos;丙子&apos;, &apos;丁丑&apos;, &apos;戊寅&apos;, &apos;己卯&apos;, &apos;庚辰&apos;, &apos;辛巳&apos;, &apos;壬午&apos;, &apos;癸未&apos;, &apos;甲申&apos;, &apos;乙酉&apos;, &apos;丙戌&apos;,&apos;丁亥&apos;, &apos;戊子&apos;, &apos;己丑&apos;, &apos;庚寅&apos;, &apos;辛卯&apos;, &apos;壬辰&apos;, &apos;癸巳&apos;, &apos;甲午&apos;, &apos;乙未&apos;, &apos;丙申&apos;, &apos;丁酉&apos;, &apos;戊戌&apos;, &apos;己亥&apos;, &apos;庚子&apos;, &apos;辛丑&apos;, &apos;壬寅&apos;, &apos;癸卯&apos;, &apos;甲辰&apos;, &apos;乙巳&apos;, &apos;丙午&apos;, &apos;丁未&apos;, &apos;戊申&apos;, &apos;己酉&apos;,&apos;庚戌&apos;, &apos;辛亥&apos;, &apos;壬子&apos;, &apos;癸丑&apos;, &apos;甲寅&apos;, &apos;乙卯&apos;, &apos;丙辰&apos;, &apos;丁巳&apos;, &apos;戊午&apos;, &apos;己未&apos;, &apos;庚申&apos;, &apos;辛酉&apos;, &apos;壬戌&apos;, &apos;癸亥&apos;] 9,map()和reduce().重点 map()函数接收两个参数,一个函数,一个Iterable, map()把函数作用在序列的每个元素上 例如: 代码如下: 12345&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] reduce的用法: reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 比方说对一个序列求和，就可以用reduce实现： 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25 10,filter() 过滤函数,和map()类似,接收两个函数,一个函数,一个序列,把传入的函数作用于每个元素,返回的是True 或 False,根据返回值判断是否保留元素. 例如，在一个list中，删掉偶数，只保留奇数，可以这么写： 1234&gt;&gt;&gt;def is_odd(n): ... return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果:[1, 5, 9, 15] 把一个序列中的空字符串删掉，可以这么写： 12345&gt;&gt;&gt;def not_empty(s):... return s and s.strip()&gt;&gt;&gt;list(filter(not_empty, [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, None, &apos;C&apos;, &apos; &apos;]))# 结果: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 11,装饰器 详细解释:网址 12,偏函数 functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2： 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&apos;1000000&apos;)64&gt;&gt;&gt; int2(&apos;1010101&apos;)85 …]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Win7-64位系统安装TensorFlow]]></title>
      <url>%2F2017%2F03%2F11%2FWin7-64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85TensorFlow%2F</url>
      <content type="text"><![CDATA[TensorFlowGitHub地址 TensorFlow支持Python2.7和3.3以上版本,本文使用Python3.5,下载并将它添加到路径当中(在安装提示最下面选项打钩即可). 阅读MD文档,找到Installation-&gt;DownLoad and Setup-&gt;Pip installation on Windows 文中提示说这个TensorFlow需要一个MSVCP140.DLL文件,你当前系统可能没有安装,应该安装 Visual C++ 2015 redistributable (x64 version).按照提示一路Next就好. 开始安装: 打开命令行提示符,win+R输入cmd,打开即可,需要安装TensorFlow的CPU和GPU CPU安装:pip install –upgrade https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.0-cp35-cp35m-win_amd64.whl 复制粘贴到命令提示符,稍等片刻,就会自动安装,安装过程中有很多类似进度条的格子,代表进度; GPU安装: pip install –upgrade https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.0-cp35-cp35m-win_amd64.whl 同样复制粘贴,同样稍等片刻,同样自动安装,同样有类似进度条格子 Cpu和GPU安装好之后,下面会有Test the TensorFlow installation来检测TensorFlow的安装情况,还会在安装一个CUDA:下载地址 安装cudnn 下载地址,将其拷贝到CUDA的安装目录下,里面3个文件夹分别有一个文件,将其按照目录拷贝到CUDA的各个对应的文件中。 将CUDA的路径添加到环境变量中… 检测是否安装成功: 在命令行中打开python 环境 12345678910111213&gt; python&gt;&gt; &gt;&gt;&gt; import tensorflow as tf&gt; &gt;&gt;&gt; hello = tf.constant(&apos;Hello, TensorFlow!&apos;)&gt; &gt;&gt;&gt; sess = tf.Session()&gt; &gt;&gt;&gt; sess.run(hello)&gt; Hello, TensorFlow!&gt; &gt;&gt;&gt; a = tf.constant(10)&gt; &gt;&gt;&gt; b = tf.constant(32)&gt; &gt;&gt;&gt; sess.run(a+b)&gt; 42&gt; &gt;&gt;&gt;&gt; 如果正确显示以上内容,就是成功了. 对抗网络学习指南,地址 安装 numpy +mkl,地址 找到numpy+mkl 下载文件的文件,shift+鼠标右键 点击在此处打开命令窗口,输入pip install+下载文件的全名.whl 安装Scipy.whl 地址 安装方法同上。 这个错误 是因为没有安装Pillow ,安装命令 pip3 install Pillow 1AttributeError: module &apos;scipy.misc&apos; has no attribute &apos;imread&apos; 可能出现的错误,基本上都能在这里找到,请耐心阅读英语, import tensorflow as tf I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cublas64_80.dll locally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cudnn64_5.dll lo cally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cufft64_80.dll l ocally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library nvcuda.dll local ly I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library curand64_80.dll locally hello = tf.constant(‘Hello,TensorFlow’) sess = tf.Session() E c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\cuda\cuda_driver.cc:509] failed call to cuInit: CUDA_ERROR_NO_DEVICE I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stream_executor\cuda\cuda_diagnostics.cc:158] retrieving CUDA diagnostic information for host: snow-PCI c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stream_executor\cuda\cuda_diagnostics.cc:165] hostname: snow-PC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新出发]]></title>
      <url>%2F2017%2F03%2F02%2FMy-New-Post%2F</url>
      <content type="text"><![CDATA[重新出发. 到目前为止,这个网站,我已经折腾3天了,从二月的最后一天,到现在,一直在忙活与创建这个个人博客… 不过感觉还不错,希望大于失望,又学习了一项新技能,内心还是禁不住泛开了花一样的开心。 是的,我喜欢新事物,喜欢学习,好奇心的确能成为促使你进步的动力,可难得的是—坚持. 对,坚持很重要,而且…是异常的难.能把一件事情坚持到底,真的十分令人敬佩. 我想说的是,无论你遇到任何困难事情,先静下心来,分析下事件的缘由,找到解决问题的突破口,一步步走起来,困难也就迎刃而解了.与此同时,吸取经验教训,争取能够在未雨绸缪. 满载信心,重新出发,永不放弃. Never Never Never Give Up.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[发现小偷]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%8F%91%E7%8E%B0%E5%B0%8F%E5%81%B7%2F</url>
      <content type="text"><![CDATA[2016年12月28号中午从新郑机场买了去郑州汽车站的巴士票。到了郑州汽车站买了两点十分回家的票,检票上车后,我看旁边有位带小孩子的年轻妈妈,就让她们俩先上车了。 ​就在这时,有一位戴着黑色口罩,左肩挎着皮包的中年男子紧跟着那位女士,一直在向上挤,我就隐隐感觉不对劲,我的眼睛在向下看,余光里模糊地看到那位男子将手伸到前面那位女士的口袋里并迅速回放到胸前,然后他就不再向上挤了,我看了他一眼,他往放行李的方向看去,然后向后退,退出排队上车的人群,我就在怀疑:他是小偷?!然后上车去了。 站在车门口将票给车上的检票人员检查,看了一眼车外,那个带着黑色口罩的男子还站在挡风玻璃前,我又盯着他看了几秒钟,对视~~ 继续朝着车后面走,然后我就想问问前面那位女士有没有丢掉什么东西。 前面有人挡着走廊了,后面有乘客上来,我就说了声:往前走一点吧。 等我把位置找到,行李放好,那位女士在走廊右侧,说了声:”我的手机被人掏走了!” 到此时,我才确定那个中年男子就是小偷! 我对那个女士说,我刚才看见下面有个人老在你后面挤,可能就是他,然后女士对我说:你怎么不告诉我?我说:当时我还不确定。 此时,最后排的一对情侣的男方说了:这个时候手机被掏走多正常啊!自己不小心点,怪谁啊?! 我觉得这句话没有同情的意思。 女士向检票人员告知无果后,借我电话向她家里说明情况,在她打电话的时候,前面一位大叔听到她向家里说手机被偷的事情,向后面看了看,我亲眼看到那位大叔一个鄙夷的眼神和一声轻微的冷笑。 我觉得这些动作并不是同情。 此时让我惊讶的是,车里都是在说这位女士真不小心,被掏走手机再正常不过了,而没人说了一句同情的话或者声讨小偷的话! 我不知道同情管不管用或者那位女士需不需要同情。 但,那是我是真的很同情她。 或许,我应该早点揭发那个小偷,可我只是发现了而已…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>%2F2017%2F02%2F28%2Farticle-tittle%2F</url>
      <content type="text"><![CDATA[时间:2017年2月28号,23:52分创建. 新的旅程刚刚开始,你要努力!]]></content>
    </entry>

    
  
  
</search>
