<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python学习(五)]]></title>
      <url>%2F2017%2F03%2F31%2FPython%E5%AD%A6%E4%B9%A0%E4%BA%94%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 多进程和多线程线程是最小的执行单元,真正的多进程是需要多核CPU支持才行,单核CPU之所以能执行多进程,是因为CPU的执行速度非常之快,在多个进程中交替执行,看起来像是多进程,实际上还是单进程.进程中包含有许多线程,像word之类的编辑文档,既需要记录用户输入的内容,又需要随时保存,打印等服务. 多进程Python中os模块封装了常见的系统调用,包括fork()方法,可以在Python中创建子进程,但是在Windows下,调用fork() 方法时,却没有… 1234567&gt;&gt;&gt; import os&gt;&gt;&gt; print(&apos;Process (%s) start...&apos; % os.getpid())Process (7088) start...&gt;&gt;&gt; pid = os.fork()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: module &apos;os&apos; has no attribute &apos;fork&apos; Windows上就没有办法编写多进程的程序了嘛?当然不是. 因为Python是跨平台的,multiprocessing模块就是跨平台的多进程模块. 123456789101112from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print(&apos;Run child process %s (%s)...&apos; % (name, os.getpid()))if name==&apos;main&apos;: print(&apos;Parent process %s.&apos; % os.getpid()) p = Process(target=run_proc, args=(&apos;test&apos;,)) print(&apos;Child process will start.&apos;) p.start() p.join() print(&apos;Child process end.&apos;) 执行结果: 1234Parent process 6288.Child process will start.Run child process test (9012)...Child process end. 创建子进程时,先创建Process实例,传入函数和函数的参数,挑用start方法启动,join方法是让子进程执行完毕后再继续向下执行,通常用于进程间同步. Pool如果需要大量的子进程,可以用进程池批量创建子进程: 123456789101112131415161718from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print(&apos;Run task %s (%s)...&apos; % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print(&apos;Task %s runs %0.2f seconds.&apos; % (name, (end - start)))if __name__ == &apos;__main__&apos;: print(&apos;Parent process %s.&apos; % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print(&apos;Waiting for all subprocesses done...&apos;) p.close() p.join() print(&apos;All subprocesses done.&apos;) 执行结果: 12345678910111213Parent process 5524.Waiting for all subprocesses done...Run task 0 (2856)...Run task 1 (7840)...Run task 2 (8688)...Run task 3 (9180)...Task 1 runs 0.75 seconds.Run task 4 (7840)...Task 4 runs 0.08 seconds.Task 0 runs 1.36 seconds.Task 3 runs 1.59 seconds.Task 2 runs 2.82 seconds.All subprocesses done. 对Pool对象调用join()方法会等待所有的子进程,调用之前必须先调用close()方法,调用close()之后就不能继续添加新的Process了. 子进程subprocess,可以启动一个子进程,然后控制其输入和输出. 12345678910111213&gt;&gt;&gt; import subprocess&gt;&gt;&gt; print(&apos;$nslookup www.python.org&apos;)$nslookup www.python.org&gt;&gt;&gt; r = subprocess.call([&apos;nslookup&apos;,&apos;www.python.org&apos;])服务器: UnKnownAddress: 192.168.0.1非权威应答:名称: python.map.fastly.netAddresses: 2a04:4e42:12::223 151.101.76.223Aliases: www.python.org&gt;&gt;&gt; print(&apos;Exit code:&apos;,r)Exit code: 0 进程间通信进程间需要通信,操作系统提供了很多机制实现进程间通信,Python的multiprocessing模块包装了底层的机制,提供了Queue,Pipes等方式交换数据. 12345678910111213141516171819202122232425262728from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): print(&apos;Process to write: %s&apos; % os.getpid()) for value in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: print(&apos;Put %s to queue...&apos; % value) q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): print(&apos;Process to read: %s&apos; % os.getpid()) while True: value = q.get(True) print(&apos;Get %s from queue.&apos; % value)if name==&apos;main&apos;: # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 启动子进程pr，读取: pr.start() # 等待pw结束: pw.join() # pr进程里是死循环，无法等待其结束，只能强行终止: pr.terminate() 结果有报错: 12345678Traceback (most recent call last): File &quot;queue.py&quot;, line 21, in &lt;module&gt; q = Queue() File&quot;C:\Users\snow\AppData\Local\Programs\Python\Python35\lib\multiprocessing\context.py&quot;,line 100, in Queue from .queues import Queue File&quot;C:\Users\snow\AppData\Local\Programs\Python\Python35\lib\multiprocessing\queues.py&quot;, line 20, in &lt;module&gt; from queue import Empty, FullImportError: cannot import name &apos;Empty&apos; 由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去,如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了. 实现跨平台多进程,使用multiprocessing模块,进程间通信,用Queu,Pipes. 多线程多任务可以由多进程来完成,也可以用多线程来完成.一个进程是由多条线程组成的,一个进程至少有一个线程. Python中提供了两个模块,_thread和threading,_thread是低级模块,threading是高级模块,对_thread进行了封装,一般情况下,用threading. 启动一个线程就是把一个函数传入并创建Thread实例,然后调用start()方法: 123456789101112131415import time, threading# 新线程执行的代码:def loop(): print(&apos;thread %s is running...&apos; % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print(&apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n)) time.sleep(1) print(&apos;thread %s ended.&apos; % threading.current_thread().name)print(&apos;thread %s is running...&apos; % threading.current_thread().name)t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)t.start()t.join()print(&apos;thread %s ended.&apos; % threading.current_thread().name) 执行结果: 123456789thread MainThread is running...thread LoopThread is running...thread LoopThread &gt;&gt;&gt; 1thread LoopThread &gt;&gt;&gt; 2thread LoopThread &gt;&gt;&gt; 3thread LoopThread &gt;&gt;&gt; 4thread LoopThread &gt;&gt;&gt; 5thread LoopThread ended.thread MainThread ended. 进程启动都会默认启动一个线程,称之为主线程,主线程的实例叫MainThread,在Python的threading模块中的 current_thread()函数,它永远返回当前线程的实例,子线程的名字在创建时指定,如果没有为子线程命名,Python会自动给线程命名Thread1,Thread2… Lock就是锁的意思.多线程和多进程最大的区别,就是在多进程中,同一变量,每个进程都有拷贝一份,互不影响.在多线程中,所有变量都由所有线程共享,任何 一个变量都可以被任何一个线程修改.所以,线程间共享数据最大的危险在于多个线程同时修改一个变量,导致变量内容错误. 123456789101112131415161718import time, threading# 假定这是你的银行存款:balance = 0def change_it(n): # 先存后取，结果应该为0: global balance balance = balance + n balance = balance - ndef run_thread(n): for i in range(100000): change_it(n)t1 = threading.Thread(target=run_thread, args=(5,))t2 = threading.Thread(target=run_thread, args=(8,))t1.start()t2.start()t1.join()t2.join()print(balance) 执行结果可能每次都不一样: 12345678910D:\Python&gt;python lock.py0D:\Python&gt;python lock.py5D:\Python&gt;python lock.py0D:\Python&gt;python lock.py-8D:\Python&gt;python lock.py0 线程的调度是由操作系统决定的,当t1,t2交替执行时候,结果可能会变掉 x为局部变量,当每个线程都有自己的变量x时: 123456789t1: x1 = balance + 5 # x1 = 0 + 5 = 5t1: balance = x1 # balance = 5t1: x1 = balance - 5 # x1 = 5 - 5 = 0t1: balance = x1 # balance = 0t2: x2 = balance + 8 # x2 = 0 + 8 = 8t2: balance = x2 # balance = 8t2: x2 = balance - 8 # x2 = 8 - 8 = 0t2: balance = x2 # balance = 0结果 balance = 0 当t1和t2交替执行时候: 12345678910初始值 balance = 0t1: x1 = balance + 5 # x1 = 0 + 5 = 5t2: x2 = balance + 8 # x2 = 0 + 8 = 8t2: balance = x2 # balance = 8t1: balance = x1 # balance = 5t1: x1 = balance - 5 # x1 = 5 - 5 = 0t1: balance = x1 # balance = 0t2: x2 = balance - 8 # x2 = 0 - 8 = -8t2: balance = x2 # balance = -8结果 balance = -8 为了防止变量的内容被多个线程修改错乱,既可以为线程加上锁(Lock),在change_it()方法加上锁,当前线程就获得了锁,其他线程就不能调用change_it()方法,必须等待锁的释放之后,才能对变量进行修改: 1234567891011balance = 0lock = threading.Lock()def run_thread(n): for i in range(100000): #先要获取锁 lock.acquire() try: change_it(n) finally: #改完了一定要释放锁 lock.release() 通过threading.Lock()来创建一个锁,加上锁之后,一定要记得通过lock.release()释放锁,否则,会导致线程为死线程. Python解释器在执行代码时,都会为每个线程加上一个GIL锁(Global Interpreter Lock),线程在执行前,必须先获得GIL锁,然后,每执行100条字节码,解释器就会自动释放GIL锁,让其他线程有机会执行,GIL全局锁,实际上把所有线程的执行代码都给加上了锁.所以,多线程在Python中只能交替执行,即使100个线程泡在100核CPU上,也只能用1核. 所以,在Python中,可以使用多线程,但不要期望有效利用多核,在Python中虽然不能利用多线程实现多核任务,但可以通过多进程实现多核任务,多个Python进程有各自独立的GIL锁,互不影响. 多线程并发在Python中,不会发生, ThreadLocal在多线程环境下,每个线程都有自己的数据,一个线程使用自己的局部变量比使用全局变量好,因为局部变量只有线程自己能看到,不会影响其他线程,而全局变量的修改必须加锁. 当你在函数调用局部变量: 12345678910111213def process_student(name): std = Student(name) # std是局部变量，但是每个函数都要用它，因此必须传进去： do_task1(std) do_task2(std)def do_task1(std): do_subtask1(std) do_subtask2(std) def do_task2(std): do_subtask2(std) do_subtask2(std) 这样的层级传递很麻烦,使用ThreadLocal时,可以简化这样的调用: 1234567891011121314151617181920import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student(): # 获取当前线程关联的student: std = local_school.student print(&apos;Hello, %s (in %s)&apos; % (std, threading.current_thread().name))def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student() t1 = threading.Thread(target= process_thread,args=(&apos;Alice&apos;,),name=&apos;Thread-A&apos;)t2 = threading.Thread(target= process_thread,args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)t1.start()t2.start()t1.join()t2.join() 输出结果: 12Hello, Alice (in Thread-A)Hello, Bob (in Thread-B) 使用threading.local()方法来创建一个全局的ThreadLocal对象–&gt;local_school 每个Thread对它都可以读写student属性,互不影响. 可以把local_school看成是全局变量,local_school.student属性都是线程的局部变量,可以任意读写而且互不干扰,也不用管锁的问题,都由ThreadLocal处理. ThreadLocal最常用的地方是,为每个线程绑定一个数据库连接,HTTP请求,用户身份信息等,这样一个线程的所有调用到的处理函数都可以方便的访问这些资源. ThreadLocal解决了参数在一个线程中各个函数间互相传递的问题.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(四)]]></title>
      <url>%2F2017%2F03%2F27%2FPython%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 IO编程文件读写取在磁盘上读写文件的功能都是由操作系统提供的,现代操作系统不允许一般的程序直接操作磁盘,读写文件就是请求操作系统打开一个文件对象,然后通过操作系统提供的接口从这个文件对象中读取数据(读文件),或者把数据写入文件对象(写文件). 使用Python内置的open()函数,传入文件路径名和标示符,就能打开一个文件,如果文件不存在,会抛出一个IOError,并指出错误出现的地方: 1234&gt;&gt;&gt; f=open(&apos;/Users/michael/notfound.txt&apos;, &apos;r&apos;)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;FileNotFoundError:[Errno 2] No such file or directory: &apos;/Users/michael/notfound.txt&apos; r,表示读取,如果打开成功,read()方法可以读取文件的全部内容,把内容读到内存,用str对象表示,最后要调用close()方法来关闭读取操作,这一步必须有,很重要. 在文件读写的过程中,都有可能发生IOError,后面的close()方法就不会执行了,Python内置的有with语句自动帮我们自动调用close()方法: 12with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f: print(f.read()) read()方法可以读取目标文件的全部内容,这不太保险,如果文件过大,内存容量不够,就挂掉了,如果文件很小的话,这个很方便. read(size)方法可以每次读取多少字节,在不确定文件大小的情况下,反复调用read(size)方法最保险. readline()可以读取一行. readlines()可以读取所有行的内容并按行返回list. 如果是配置文件,这个很方便. 按照需求,选取合适的方法. 二进制文件的读取,如图片,视频,用’rb‘模式打开: 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)&gt;&gt;&gt; f.read()b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节 想要读取特定编码的文件对象,需要在open()函数中传入编码类型encoding: 123&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)&gt;&gt;&gt; f.read()&apos;测试&apos; 如遇到编码不规范的文件,可能会有UnicodeDecodeError. 文件中可能含有非法字符,在open()函数中黑可以传入一个errors参数,表示如果遇到异常如何处理, 1&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;, errors=&apos;ignore&apos;) 文件写入文件写入和文件读取类似,只不过在open()函数中的参数是’w’和’wb’,用来读取文本文件和二进制文件 123&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)&gt;&gt;&gt; f.close() 用with语句最保险: 12with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f: f.write(&apos;Hello, world!&apos;) 反复调用write()方法,最重要的是还要调用close()方法,这样才能保证,系统把数据全部写入到指定文件中,如果要指定编码类型,只需要在open()函数中传入指定的的编码就可以了. StringIO 是在内存中读写str: 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write(&apos;hello&apos;)5 #字符个数&gt;&gt;&gt; f.write(&apos; &apos;)1&gt;&gt;&gt; f.write(&apos;world!&apos;)6&gt;&gt;&gt; print(f.getvalue())hello world! getvalue()是用于获取写入后的字符串. 读取StringIO和读取文件类似 1234567891011&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;)&gt;&gt;&gt; while True:... s = f.readline()... if s == &apos;&apos;:... break... print(s.strip())...Hello!Hi!Goodbye! BytesIO用于读写二进制数据. 12345&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))6&gt;&gt;&gt; print(f.getvalue())b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 用BytesIO写入的不是str,而是经过编码后的byte字节,读取类似StringIO,先获得BytesIO的对象,进行读取: 1234&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)&gt;&gt;&gt; f.read()b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 操作文件和目录在Python中操作文件和目录的命令都在os模块和os.path模块当中 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.name &apos;nt&apos; 操作系统类型,nt 代表Windows,还有POSIX类型,代表Linux,Unix,或者MacOs. 环境变量: 1&gt;&gt;&gt; os.environ 取得某个环境变量的值: 1&gt;&gt;&gt; os.environ.get(&apos;path&apos;) 当前目录的绝对路径: 1&gt;&gt;&gt; os.path.abspath(&apos;.&apos;) 把两个路径合成一个时: 1os.path.join() 拆分路径: 12&gt;&gt;&gt; os.path.split(&apos;C:/Users/snow/Desktop/22.txt&apos;)(&apos;C:/Users/snow/Desktop&apos;, &apos;22.txt&apos;) 拆分直接得到文件扩展名: 12&gt;&gt;&gt; os.path.splitext(&apos;C:/Users/snow/Desktop/22.txt&apos;)(&apos;C:/Users/snow/Desktop/22&apos;, &apos;.txt&apos;) 合并,拆分路径操作,并不要次文件真实存在,只是对字符串进行操作. 对文件重命名: 1&gt;&gt;&gt;os.rename(&apos;test.txt&apos;, &apos;test.py&apos;) 删掉文件: 1&gt;&gt;&gt;os.remove(&apos;test.py&apos;) shutil模块中有copyfile()函数. 列出当前目录下的所有文件夹: 12&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)][&apos;DLLs&apos;, &apos;Doc&apos;, &apos;include&apos;, &apos;Lib&apos;, &apos;libs&apos;, &apos;Scripts&apos;, &apos;tcl&apos;, &apos;Tools&apos;] 列出所有的.py文件: 123&gt;&gt;&gt; import os&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;][&apos;break.py&apos;, &apos;if.py&apos;, &apos;learning.py&apos;, &apos;secret.py&apos;, &apos;sum.py&apos;, &apos;turtle.py&apos;] 序列化把变量从内存中变成可存储或传输的过程称之为序列化,在Python中叫pickling,序列化之后,就可以把序列化后的内容写入磁盘,或者通过网络传输到别的机器上. 反过来,把序列化之后的对象读到内存中,称为反序列化,unpickling. pickle模块实现序列化: 1234&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&apos;Snow&apos;,age=20,score=88)&gt;&gt;&gt; pickle.dumps(d)b&apos;\x80\x03&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x04\x00\x00\x00Snowq\x02X\x05\x00\x00\x00scoreq\x03KXX\x03\x00\x00\x00ageq\x04K\x14u.&apos; pickle.dumps()方法可以把任意对象序列化成一个bytes,然后,就可以把bytes写入文件,或者,用pickle.dump()直接把对象序列化后写入一个file-like-Object: 123456&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&apos;snow&apos;,age =22,sorce=90)&gt;&gt;&gt; f = open(&apos;33.txt&apos;,&apos;wb&apos;)&gt;&gt;&gt; pickle.dump(d,f)&gt;&gt;&gt; f.close&lt;built-in method close of _io.BufferedWriter object at 0x00000000011AA938&gt; 33.txt中的内容像这样: 12345678003 7d71 0028 5803 0000 0061 6765 71014b16 5805 0000 0073 6f72 6365 7102 4b5a5804 0000 006e 616d 6571 0358 0400 0000736e 6f77 7104 752e 8003 7d71 0028 58030000 0061 6765 7101 4b16 5805 0000 00736f72 6365 7102 4b5a 5804 0000 006e 616d6571 0358 0400 0000 736e 6f77 7104 752e 当把对象从磁盘中读到内存时候,可以先读取一个bytes,然后用pickle.loads()方法反序列化出对象,也可以用pickl.load()方法从一个file-like-Object中直接反序列化出对象, 12345&gt;&gt;&gt; f = open(&apos;33.txt&apos;,&apos;rb&apos;)&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;&apos;age&apos;: 22, &apos;sorce&apos;: 90, &apos;name&apos;: &apos;snow&apos;&#125; pickle只能用于python,不同版本的互不兼容,只能用pickle存储一些不太重要的信息. JSON要在不同编程语言之间传递对象,就要把对象序列化为标准格式,JSON表示的是一个字符串,可以被所有语言读取,可以方便的存储到磁盘或者通过网络传输,可以直接在Web页面读取. JSON类型 Python类型 {} dict [] list “string” str 1234.56 int或float true/false True/False null None python对象转化为JSON: 1234&gt;&gt;&gt; import json&gt;&gt;&gt; d = dict(name=&apos;snow&apos;,age =22,sorce=90)&gt;&gt;&gt; json.dumps(d)&apos;&#123;&quot;age&quot;: 22, &quot;sorce&quot;: 90, &quot;name&quot;: &quot;snow&quot;&#125;&apos; 使用JSON反序列化为Python对象,用loads(),或者load()方法,loads()方法将JSON的字符串反序列化,load()方法将从file-like-Object读取字符串并反序列化: 1234&gt;&gt;&gt; import json&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 22, &quot;sorce&quot;: 90, &quot;name&quot;: &quot;snow&quot;&#125;&apos;&gt;&gt;&gt; json.loads(json_str)&#123;&apos;name&apos;: &apos;snow&apos;, &apos;age&apos;: 22, &apos;sorce&apos;: 90&#125; JSON标准规定JSON编码是UTF-8. Python语言序列化的模块是pickle,想要把序列化更通用,更符合web标准,就可以用JSON.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(三)]]></title>
      <url>%2F2017%2F03%2F25%2FPython%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 面型对象高级编程数据封装,继承和多态只是面向对象编程的3个基础概念 __slots__定义一个Class后,创建一个class实例后,可以给实例绑定任何属性和方法,动态语言的灵活性, 12class Student(object): pass 创建实例,绑定一个属性值: 123&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = &apos;Michael&apos; # 动态给实例绑定一个属性&gt;&gt;&gt; print(s.name)Michael 还可以为其绑定一个方法, 但是,这个方法只对当前实例有效,对其他实例没有效果。 使用 __slots__ 可以为类限定以后添加的属性, 12class Student(object): slots = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称 这样,除了name和age属性之外的属性,都不可以添加了,会报错 1234567&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos; 使用 __slots__ 仅对当前实例有效,对其子类则没有效果,除非在子类中定义 __slots__ 方法 @property@property就是可以让实例的方法当做属性来用,例如:给Screen对象加上width和height属性,以及一个只读属性的resolution, 1234567891011121314151617181920class Screen(object): @property #设置getter方法 def width(self): return self._width @width.setter #设置setter方法 def width(self,value): self._width = value @property #设置getter方法 def height(self): return self._height @height.setter #设置setter方法 def height(self,value): self._height = value @property #没有setter方法,只读属性,通过计算出来的 def resolution(self): return self.width*self.height 测试结果: 12345s = Screen()s.width = 1024 #这里就相当于s.set_widths.height = 768 #这里就相当于s.set_heightprint(s.resolution) 786432 多重继承Python允许使用多重继承,例如:狗是一种会跑的,食肉的,哺乳型动物,就可以继承自定义的 会跑的动物(Runnable),食肉的(Carnivorous),哺乳型(Mammal),动物(Animal)… 12class Dog(Mammal,Animal,Carnivorous): pass 这种模式叫做MixIn,目的是为了给一个类增加多个功能,在设计类的时候,优先考虑通过多重继承来组合多个MixIn的功能,而不是设计复杂层次的继承关系, Enum枚举类12345678910from enum import Enum, unique@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 @unique用来检查有没有重复值 访问枚举类型 12345678&gt;&gt;&gt; print(Weekday.Tue)Weekday.Tue&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])Weekday.Tue&gt;&gt;&gt; print(Weekday.Tue.value)2&gt;&gt;&gt; print(Weekday(1))Weekday.Mon 可以根据枚举名称引用常量,也可以用value的值获取枚举常量 元类(metalclass)动态语言在函数和类的定义过程中,不是编译时定义的 ,而是运行时动态创建的, 当我们需要创建一个实例时,首先要先定义一个类,然后在创建类的实例,所以顺序就是 –&gt;创建类–&gt;创建实例, 但是创建类的时候呢?这是就是先创建metalclass,在创建类,在创建实例,顺序就是–&gt;创建metalclass–&gt;创建类–&gt;创建类的实例 可以理解为,类就是metalclass的实例, ①它可以拦截类的创建, ②对类进行修改 ③返回修改后的类 详细解释 错误,调试,测试①,错误处理try…except…finally…错误处理机制 123456789try: print(&apos;try...&apos;) r = 10 / 0 print(&apos;result:&apos;, r)except ZeroDivisionError as e: print(&apos;except:&apos;, e)finally: print(&apos;finally...&apos;)print(&apos;END&apos;) 当try执行代码块出错时候,后续代码将不执行,而是执行except语句中的代码,提示错误的出现,如果finally语句中有代码,再执行其语句中的代码, 1234try...result: 5finally...END 也可以添加多个except语句块,捕获不同错误,还可以加入else语句块, 123456except ValueError as e: print(&apos;ValueError:&apos;, e)except ZeroDivisionError as e: print(&apos;ZeroDivisionError:&apos;, e)else: print(&apos;no error!&apos;) 错误类型和继承关系 try…except..还可以跨越多层级调用,可以减少try..except..代码块的书写 1234567891011def foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar(&apos;0&apos;) except Exception as e: print(&apos;Error:&apos;, e) finally: print(&apos;finally...&apos;) 如果错误没有被捕获,会一直向上抛,直到Python解释器捕获,打印错误信息,程序退出, 出现错误不可怕,不知道错误出现在哪里才可怕,要找到错误出现的地方,出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。 通过logging可以方便的记录错误, 12except Exception as e: logging.exception(e) 抛出错误raise 12345def foo(s): n = int(s) if n==0: raise FooError(&apos;invalid value: %s&apos; % s) return 10 / n 只有在必要的时候才使用自定义的错误类,如果可以用Python内置的错误类,尽量使用内置的错误类, ②调试程序调试的方法有: print()直接打印处错误,还需要手动删除 断言assert, 123456def foo(s): n = int(s) assert n != 0, &apos;n is zero!&apos; return 10 / ndef main(): foo(&apos;0&apos;) 表达式 n!=0应该是true,否则,后面的代码会出错,如果断言失败,会抛出AssertionError, 启用Python解释器时候,可以启用-0来关闭断言 1$ python3 -0 err.py logging,它不会抛出错误,可以输出到文件,可以指定记录信息的级别,debug,info,warning,error等, pdb,python自带的调试器, 1234# err.pys = &apos;0&apos;n = int(s)print(10 / n) 启动调试器: 123$ python3 -m pdb err.py&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()-&gt; s = &apos;0&apos; 输入命令n可以单步执行代码, 123456(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()-&gt; n = int(s)(Pdb) n&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()-&gt; print(10 / n) 输入 p 变量名 可以查看变量 1234(Pdb) p s&apos;0&apos;(Pdb) p n0 输入q 退出调试 pdb.set_trace(),这个方法也是pdb调试的,但不需要单步执行, 123456# err.pyimport pdbs = &apos;0&apos;n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n) 只需要在可能出现错误的地方,加上pdb.set_trace(),代码执行到此时,会自动进入pdb调试模式,可以用p查看变量,用c继续执行 12345678910$ python3 err.py &gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()-&gt; print(10 / n)(Pdb) p n0(Pdb) cTraceback (most recent call last):File &quot;err.py&quot;, line 7, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero IDE调试,比较好的Python IDE 有PyCharm ③单元测试单元测试时对一个类,一个函数或者一个模块正确性检测的测试工作,就是确保一个程序模块的行为符合我们设计的测试用例,在将来进行修改时候,极大可能保证此模块仍然是正确的 ④文档测试Python内置的 文档测试(doctest) 可以抽取文档中的代码直接运行 doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确 12345678910111213141516171819def fact(n): &apos;&apos;&apos;&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(2)2&gt;&gt;&gt; fact(-1)Traceback (most recent call last):ValueError &apos;&apos;&apos; if n &lt; 1: raise ValueError() if n == 1: return 1 return n * fact(n - 1)if__name__ == &apos;__main__&apos;: import doctest doctest.testmod()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(二)]]></title>
      <url>%2F2017%2F03%2F24%2FPython%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 模块模块最大的好处就是提高了代码的可维护性,避免函数名和包名的冲突, 使用和安装第三方模块先import导入,第三方模块,就能用到数据此模块当中的函数和属性 下载地址 面向对象编程Object Oriented Programming 简称OOP,是一种程序设计思想,OOP把对象作为程序的基本单元,一个对象包含函数和操作函数的方法; 类和实例面向对象最重要的概念类(class)和实例(instance) 1234class Student(object): def init(self, name, score): self.name = name self.score = score init 前后有两个下划线,第一个参数始终是self, 访问限制Class内部有属性和方法,外部可以直接用实例来操作类的属性和方法,隐藏了内部复杂的逻辑, 如果不想让内部属性被外部访问,可以把属性名称前面加上两个下划线__,这样内部属性就变成了私有变量,外部不可访问; 1234class Student(object): def init(self, name, score): self.name = name self.score = score 如果需要对属性变量进行更改或取值,可以给类添加get和set方法,通过,get_name,set_sorce,进行修改; 123456789class Student(object): ... def get_name(self): return self.__name def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError(&apos;bad score&apos;) 其次, __XXX__ 类似这样前后带有双下划线的变量,不是私有变量,可以随意访问. _XXX 带有一个下划线的变量,视为私有变量,不要轻易访问; 带有双下划线的私有变量一定要从外部访问嘛? 不一定,带有双下划线的私有变量,Python解释器,其实把, __name 变量给成了_Student__name, 所以,还是可以通过,_Student__name 的形式进行访问; 但是,强烈建议不要这么做.因为不同版本的Python解释器可能会把 __name 改成不同的变量; 继承和多态继承最大的好处就是,子类可以拥有父类的全部方法和功能 123class Animal(object): def run(self): print(&apos;Animal is running...&apos;) 123class Dog(Animal): def run(self): print(&apos;Dog is running...&apos;) 123class Cat(Animal): def run(self): print(&apos;Cat is running...&apos;) Animal就是Dog,Cat的父类,Dog,Cat就是Animal的子类,并拥有父类的全部方法 子类和父类中拥有相同run()方法,说明子类run()方法覆盖了父类run()的方法,代码运行时候就会调用 子类的run()方法,这就是继承的另一个好处:多态 当然也可以添加父类没有的方法 判断一个变量是否是某个类型可以用isinstance()判断： 12&gt;&gt;&gt; isinstance(c, Animal)True 继承关系树: 静态语言 vs 动态语言 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者 它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一 个run()方法就可以了： 获取对象信息想要知道该对象是什么类型的 ①.type()方法123456&gt;&gt;&gt; type(123)&lt;class &apos;int&apos;&gt;&gt;&gt;&gt; type(&apos;str&apos;)&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; type(None)&lt;type(None) &apos;NoneType&apos;&gt; type返回的是对应的Class类型. 比较两个变量的type类型是否相同: ②.instance()方法先创建变量类型: 123&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky() 判断: 1234&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)True ③.dir()方法想要或去一个对象的所有属性和方法,可以使用dir()方法,返回的是一个包含字符串的list,如: 1&gt;&gt;&gt; dir(&apos;ABC&apos;) 1[&apos;add&apos;, &apos;class&apos;, &apos;contains&apos;, &apos;delattr&apos;, &apos;dir&apos;, &apos;doc&apos;, &apos;eq&apos;, &apos;format&apos;, &apos;ge&apos;, &apos;getattribute&apos;, &apos;getitem&apos;, &apos;getnewargs&apos;, &apos;gt&apos;, &apos;hash&apos;, &apos;init&apos;, &apos;iter&apos;, &apos;le&apos;, &apos;len&apos;, &apos;lt&apos;, &apos;mod&apos;, &apos;mul&apos;, &apos;ne&apos;, &apos;new&apos;, &apos;reduce&apos;, &apos;reduce_ex&apos;, &apos;repr&apos;, &apos;rmod&apos;, &apos;rmul&apos;, &apos;setattr&apos;, &apos;sizeof&apos;, &apos;str&apos;, &apos;subclasshook&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;] 还可以配合,getattr(),setattr()和hasattr()方法来操作属性和方法,如: 123456&gt;&gt;&gt; class MyObject(object):... def init(self):... self.x = 9... def power(self):... return self.x * self.x...&gt;&gt;&gt; obj = MyObject() 然后,测试是否含有属性: 12345678910111213&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？False&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？True&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;19&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;19 如果试图获取不存在的属性,会报错:AttributeError的错误 实例属性和类属性在编写实例属性和类属性的话,尽量不要使用相同的名字,相同名称的实例属性会覆盖掉类属性,如果 删除掉实例属性的话,再用相同名称,访问到的是类属性.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习(一)]]></title>
      <url>%2F2017%2F03%2F12%2FPython%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
      <content type="text"><![CDATA[学习网址:廖雪峰的Python教程 list:Pytho内置的数据类型列表,list是一种可变有序集合,可以随时添加和删除其中的元素.可添加元素到末尾. 123&gt;&gt;&gt; classmates.append(&apos;Adam&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 也可以指定索引号,添加到指定位置, 123&gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] 删除元素: pop()方法 删除末尾元素,也可指定索引删除指定位置pop(i) tuple另外一种有序列表,元组,和list非常相似,但tuple一旦初始化,就不能更改, 代码更安全,能用tuple替代list,就替换掉, 定义一个元素时,例子: 12&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 条件判断1234567&gt;&gt;&gt;age = 20&gt;&gt;&gt;if age &gt;= 6: ... print(&apos;teenager&apos;)...elif age &gt;= 18: ... print(&apos;adult&apos;)...else: ... print(&apos;kid&apos;) 循环123&gt;&gt;&gt;sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:... sum = sum + x... print(sum) range()函数:整数序列,包前不包后,range(5) 表示(0,1,2,3,4) 要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。 dictPython 内置的词典,极快的查找速度,原因 dict通过索引查找 一个Key对应一个value,如果有多个,后面的话替换掉前面的 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 需要牢记的第一条就是dict的key必须是不可变对象。 set一组key的集合,不存储value,在set中没有重复的key,无序的无重复的集合 重复元素自动过滤, add(key)添加元素,remove(key)删除元素 函数定义函数时，需要确定函数名和参数个数； 如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果； 函数执行完毕也没有return语句时，自动return None。 函数可以同时返回多个值，但其实就是一个tuple。 Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 切片:1&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 前十个数,取法 1&gt;&gt;&gt; L:10 L[开始位置:结束位置:间隔数],包含开始,不包含结束,每隔 间隔数 取数值 从10开始,每隔5取一个数,到90(不包含90)结束. 1&gt;&gt;&gt; L[10:90:5] 1[10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85] 123456&gt;&gt;&gt; tiangan = &apos;甲乙丙丁戊己庚辛壬癸&apos;&gt;&gt;&gt; dizhi = &apos;子丑寅卯辰巳午未申酉戌亥&apos;&gt;&gt;&gt;&gt;&gt;&gt; jiazi = [tiangan[x % len(tiangan)] + dizhi[x % len(dizhi)] for x in range(60)]&gt;&gt;&gt;&gt;&gt;&gt; print(jiazi) 1[&apos;甲子&apos;, &apos;乙丑&apos;, &apos;丙寅&apos;, &apos;丁卯&apos;, &apos;戊辰&apos;, &apos;己巳&apos;, &apos;庚午&apos;, &apos;辛未&apos;, &apos;壬申&apos;, &apos;癸酉&apos;, &apos;甲戌&apos;, &apos;乙亥&apos;, &apos;丙子&apos;, &apos;丁丑&apos;, &apos;戊寅&apos;, &apos;己卯&apos;, &apos;庚辰&apos;, &apos;辛巳&apos;, &apos;壬午&apos;, &apos;癸未&apos;, &apos;甲申&apos;, &apos;乙酉&apos;, &apos;丙戌&apos;,&apos;丁亥&apos;, &apos;戊子&apos;, &apos;己丑&apos;, &apos;庚寅&apos;, &apos;辛卯&apos;, &apos;壬辰&apos;, &apos;癸巳&apos;, &apos;甲午&apos;, &apos;乙未&apos;, &apos;丙申&apos;, &apos;丁酉&apos;, &apos;戊戌&apos;, &apos;己亥&apos;, &apos;庚子&apos;, &apos;辛丑&apos;, &apos;壬寅&apos;, &apos;癸卯&apos;, &apos;甲辰&apos;, &apos;乙巳&apos;, &apos;丙午&apos;, &apos;丁未&apos;, &apos;戊申&apos;, &apos;己酉&apos;,&apos;庚戌&apos;, &apos;辛亥&apos;, &apos;壬子&apos;, &apos;癸丑&apos;, &apos;甲寅&apos;, &apos;乙卯&apos;, &apos;丙辰&apos;, &apos;丁巳&apos;, &apos;戊午&apos;, &apos;己未&apos;, &apos;庚申&apos;, &apos;辛酉&apos;, &apos;壬戌&apos;, &apos;癸亥&apos;] map()和reduce().重点 map()函数接收两个参数,一个函数,一个Iterable, map()把函数作用在序列的每个元素上 例如: 代码如下: 12345&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] reduce的用法: reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 比方说对一个序列求和，就可以用reduce实现： 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25 filter()过滤函数,和map()类似,接收两个函数,一个函数,一个序列,把传入的函数作用于每个元素,返回的是True 或 False,根据返回值判断是否保留元素. 例如，在一个list中，删掉偶数，只保留奇数，可以这么写： 1234&gt;&gt;&gt;def is_odd(n): ... return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果:[1, 5, 9, 15] 把一个序列中的空字符串删掉，可以这么写： 12345&gt;&gt;&gt;def not_empty(s):... return s and s.strip()&gt;&gt;&gt;list(filter(not_empty, [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, None, &apos;C&apos;, &apos; &apos;]))# 结果: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 装饰器详细解释:网址 偏函数functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2： 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&apos;1000000&apos;)64&gt;&gt;&gt; int2(&apos;1010101&apos;)85]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Win7-64位系统安装TensorFlow]]></title>
      <url>%2F2017%2F03%2F11%2FWin7-64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85TensorFlow%2F</url>
      <content type="text"><![CDATA[TensorFlowGitHub地址 TensorFlow支持Python2.7和3.3以上版本,本文使用Python3.5,下载并将它添加到路径当中(在安装提示最下面选项打钩即可). 阅读MD文档,找到Installation-&gt;DownLoad and Setup-&gt;Pip installation on Windows 文中提示说这个TensorFlow需要一个MSVCP140.DLL文件,你当前系统可能没有安装,应该安装 Visual C++ 2015 redistributable (x64 version).按照提示一路Next就好. 开始安装: 打开命令行提示符,win+R输入cmd,打开即可,需要安装TensorFlow的CPU和GPU CPU安装:pip install –upgrade https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-1.0.0-cp35-cp35m-win_amd64.whl 复制粘贴到命令提示符,稍等片刻,就会自动安装,安装过程中有很多类似进度条的格子,代表进度; GPU安装: pip install –upgrade https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-1.0.0-cp35-cp35m-win_amd64.whl 同样复制粘贴,同样稍等片刻,同样自动安装,同样有类似进度条格子 Cpu和GPU安装好之后,下面会有Test the TensorFlow installation来检测TensorFlow的安装情况,还会在安装一个CUDA:下载地址 安装cudnn 下载地址,将其拷贝到CUDA的安装目录下,里面3个文件夹分别有一个文件,将其按照目录拷贝到CUDA的各个对应的文件中。 将CUDA的路径添加到环境变量中… 检测是否安装成功: 在命令行中打开python 环境 12345678910111213&gt; python&gt;&gt; &gt;&gt;&gt; import tensorflow as tf&gt; &gt;&gt;&gt; hello = tf.constant(&apos;Hello, TensorFlow!&apos;)&gt; &gt;&gt;&gt; sess = tf.Session()&gt; &gt;&gt;&gt; sess.run(hello)&gt; Hello, TensorFlow!&gt; &gt;&gt;&gt; a = tf.constant(10)&gt; &gt;&gt;&gt; b = tf.constant(32)&gt; &gt;&gt;&gt; sess.run(a+b)&gt; 42&gt; &gt;&gt;&gt;&gt; 如果正确显示以上内容,就是成功了. 对抗网络学习指南,地址 安装 numpy +mkl,地址 找到numpy+mkl 下载文件的文件,shift+鼠标右键 点击在此处打开命令窗口,输入pip install+下载文件的全名.whl 安装Scipy.whl 地址 安装方法同上。 这个错误 是因为没有安装Pillow ,安装命令 pip3 install Pillow 1AttributeError: module &apos;scipy.misc&apos; has no attribute &apos;imread&apos; 可能出现的错误,基本上都能在这里找到,请耐心阅读英语, import tensorflow as tf I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cublas64_80.dll locally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cudnn64_5.dll lo cally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library cufft64_80.dll l ocally I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library nvcuda.dll local ly I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\dso_loader.cc:135] successfully opened CUDA library curand64_80.dll locally hello = tf.constant(‘Hello,TensorFlow’) sess = tf.Session() E c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stre am_executor\cuda\cuda_driver.cc:509] failed call to cuInit: CUDA_ERROR_NO_DEVICE I c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stream_executor\cuda\cuda_diagnostics.cc:158] retrieving CUDA diagnostic information for host: snow-PCI c:\tf_jenkins\home\workspace\release-win\device\gpu\os\windows\tensorflow\stream_executor\cuda\cuda_diagnostics.cc:165] hostname: snow-PC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重新出发]]></title>
      <url>%2F2017%2F03%2F02%2FMy-New-Post%2F</url>
      <content type="text"><![CDATA[重新出发. 到目前为止,这个网站,我已经折腾3天了,从二月的最后一天,到现在,一直在忙活与创建这个个人博客… 不过感觉还不错,希望大于失望,又学习了一项新技能,内心还是禁不住泛开了花一样的开心。 是的,我喜欢新事物,喜欢学习,好奇心的确能成为促使你进步的动力,可难得的是—坚持. 对,坚持很重要,而且…是异常的难.能把一件事情坚持到底,真的十分令人敬佩. 我想说的是,无论你遇到任何困难事情,先静下心来,分析下事件的缘由,找到解决问题的突破口,一步步走起来,困难也就迎刃而解了.与此同时,吸取经验教训,争取能够在未雨绸缪. 满载信心,重新出发,永不放弃. Never Never Never Give Up.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[发现小偷]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%8F%91%E7%8E%B0%E5%B0%8F%E5%81%B7%2F</url>
      <content type="text"><![CDATA[2016年12月28号中午从新郑机场买了去郑州汽车站的巴士票。到了郑州汽车站买了两点十分回家的票,检票上车后,我看旁边有位带小孩子的年轻妈妈,就让她们俩先上车了。 ​就在这时,有一位戴着黑色口罩,左肩挎着皮包的中年男子紧跟着那位女士,一直在向上挤,我就隐隐感觉不对劲,我的眼睛在向下看,余光里模糊地看到那位男子将手伸到前面那位女士的口袋里并迅速回放到胸前,然后他就不再向上挤了,我看了他一眼,他往放行李的方向看去,然后向后退,退出排队上车的人群,我就在怀疑:他是小偷?!然后上车去了。 站在车门口将票给车上的检票人员检查,看了一眼车外,那个带着黑色口罩的男子还站在挡风玻璃前,我又盯着他看了几秒钟,对视~~ 继续朝着车后面走,然后我就想问问前面那位女士有没有丢掉什么东西。 前面有人挡着走廊了,后面有乘客上来,我就说了声:往前走一点吧。 等我把位置找到,行李放好,那位女士在走廊右侧,说了声:”我的手机被人掏走了!” 到此时,我才确定那个中年男子就是小偷! 我对那个女士说,我刚才看见下面有个人老在你后面挤,可能就是他,然后女士对我说:你怎么不告诉我?我说:当时我还不确定。 此时,最后排的一对情侣的男方说了:这个时候手机被掏走多正常啊!自己不小心点,怪谁啊?! 我觉得这句话没有同情的意思。 女士向检票人员告知无果后,借我电话向她家里说明情况,在她打电话的时候,前面一位大叔听到她向家里说手机被偷的事情,向后面看了看,我亲眼看到那位大叔一个鄙夷的眼神和一声轻微的冷笑。 我觉得这些动作并不是同情。 此时让我惊讶的是,车里都是在说这位女士真不小心,被掏走手机再正常不过了,而没人说了一句同情的话或者声讨小偷的话! 我不知道同情管不管用或者那位女士需不需要同情。 但,那是我是真的很同情她。 或许,我应该早点揭发那个小偷,可我只是发现了而已…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>%2F2017%2F02%2F28%2Farticle-tittle%2F</url>
      <content type="text"><![CDATA[时间:2017年2月28号,23:52分创建. 新的旅程刚刚开始,你要努力!]]></content>
    </entry>

    
  
  
</search>
